WRITE:
-Operators
-Solvers

INTERFACE EXTENSIONS:
-accessors (to make conversion float<->double simpler)
-shifted solver fields




Init:
1. allocate a QMP block for each send and one for all receives for a given
   precision.
2. On even and odd:
  2.3 Build all REAL sends
  2.4 Build all REAL receive, convert to compounds.
3. Check that global sum should be called -- ?

Fini:
1. For even and odd
  1.1 Free receive handle
  1.2 Free all send handles
2. Free QMP memories

Setting parameters
1. If error is not recordable return
2. Allocate memory for generics
3. Build generic parameters
4. Call generics
5. Free memory


F-like operators:
1. Start combined receive
2. Start each down face:
   2.1 Finish send if outstanding
   2.2 Compute projection
   2.3 Start send
   2.4 Mark send outstanding
3. Start each up face:
   3.1 Finish send if outstanding
   3.2 Compute projection * U
   3.3 Start send
   3.4 Mark send outstanding
4. Compute body part
5. Wait for combined receive to finish
6. Compute face part

Diagonals:
1. For the full e/o do what needs to be done on each 4-d point.

;;;;;
;; RTL:
;;
for each primitive type define

name -- symbol naming the type
size -- accessed with (size-of <name>)
align -- accessed with (align-of <name>)

Compound types, aka structure:
<structure> := (structure <struct-name> (<field>*))
<field> := (<field-name> <field-type>)
this defines:

<size-of>    := (size-of <struct-name>)
<align-of>   := (align-of <struct-name>)
<offset-off> := (offset-of <struct-name> <field-name>)

Also,
<type-alias> := (type-alias <new-name> <old-name>) -- type alias

All these should agree with C on the target machine.

RTL file structure:
<file> :=
  <decl>*

<decl> :=
   | <constant>
   | <type-alias>
   | <structure>
   | <procedure>

<procedure> :=
   (procedure (<attribute>*)
      (<arg>*)
      <operation>)

<attribute> := 
    <symbol>
    (<symbol> <value> ...)

<value> :=
      <const-expr>
    | <string>
    | <symbol>

<arg> :=
   (<name> <attribute>*)

<operation> :=
   <condition>
  | <block>
  | <loop>
  | <op>
  | <load>
  | <store>

<condition> :=
  (if (<attribute>*) <in>
       <operation>
       <operation>)

<block> :=
  (begin (<attribute>*) <operation>+)

<loop> :=
   (loop (<attribute>*)
         (<out>    ; induction variable
             <in>  ; inclusive low limit
             <in>) ; exclusive upper limit
         <operation>+)

<op> :=
   (op <name> (<attribute>*) (<out>*) (<in>*))

<out> :=
   <symbol>

<in> :=
    (const <const-expr>)
  | (reg <symbol>)

<const-expr> :=
    <number>
   | <symbol>
   | <size-of>
   | <offset-of>
   | <align-of>
   | (add <const-expr> <const-expr>)
   | (sub <const-expr> <const-expr>)
   | (mul <const-expr> <const-expr>)

<constant> :=
   (define-constant <symbol> <const-expr>)

<load> :=
   (load <type> (<attribute>*) <out> (<in>+))

<store> :=
   (store <type> (<attribute>*) (<in>+) <in>)
