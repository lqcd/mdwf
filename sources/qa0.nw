\documentclass[twoside]{article}
\usepackage{noweb}
\noweboptions{externalindex,longchunks,longxref}
\usepackage{color}
\definecolor{darkblue}{cmyk}{1,1,0,0.7}
\usepackage[dvipdfm,colorlinks=true,linkcolor=darkblue]{hyperref}
\newcommand{\note}[1]{$[\![$NB: #1$]\!]$}
\setlength{\parindent}{0pt}
\setlength{\topmargin}{-40pt}
\setlength{\oddsidemargin}{-16pt}
\setlength{\evensidemargin}{-16pt}
\setlength{\textwidth}{522pt}
\setlength{\textheight}{680pt}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\title{QA---Register Transfer Language}
\author{Andrew Pochinsky}
\catcode`\$=11
\date{$Id$}
\catcode`\$=3

\newcommand{\any}{${}^{*}$}
\newcommand{\oneplus}{${}^{+}$}
\newcommand{\nonterminal}[1]{$\langle$\emph{#1}$\rangle$}
\newcommand{\is}{&$\rightarrow$&&}
\newcommand{\also}{&&$|$&}
\newcommand{\terminal}[1]{\texttt{#1}}
\newcommand{\nothing}{\terminal{/* nothing */}}
\newenvironment{grammar}{\par\medskip\begin{tabular}{lccl}}{%
\end{tabular}\medskip\par}

\begin{document}
\maketitle
\section{GRAMMAR}
Here we define the grammar for QA. We start with the file level constructs:

\begin{grammar}
\nonterminal{qa0} \is \nonterminal{decl}\any\\
\nonterminal{decl}\is\nonterminal{alias}\\
  \also\nonterminal{constant}\\
  \also\nonterminal{structure}\\
  \also\nonterminal{array}\\
  \also\nonterminal{top level macro}\\
\nonterminal{top level macro}\is\nonterminal{procedure}\\
  \also\terminal{(} \terminal{repeat}
         \terminal{(} \nonterminal{iterator}\any \terminal{)}
         \nonterminal{top level macro}\oneplus \terminal{)}\\
\end{grammar}

There are two kinds of iterators. One is an enumeration, another is loop-like
\begin{grammar}
\nonterminal{iterator}\is\terminal{(}
   \nonterminal{name} \terminal( \nonterminal{a-value}\oneplus \terminal)
     \terminal{)}\\
  \also\terminal{(}
   \nonterminal{name} \nonterminal{inclusive constant low}
      \nonterminal{exclusive constant high} \terminal{)}\\
\nonterminal{inclusive constant low}\is\nonterminal{constant expr}\\
\nonterminal{exclusive constant high}\is\nonterminal{constant expr}\\
\end{grammar}

Integer constants may be defined and given names. We do not specify the
allowed set of operations in \nonterminal{c-expr} here,
they will be introduced as needed.

\begin{grammar}
\nonterminal{constant}\is\terminal{(} \terminal{constant}
 \nonterminal{name} \nonterminal{constant expression}\terminal{)}\\
\nonterminal{constant expression}\is\terminal{(} \terminal{const}
  \nonterminal{c-expr} \terminal{)}\\
\nonterminal{c-expr}\is\nonterminal{number}\\
  \also\nonterminal{name}\\
  \also\nonterminal{string}\\
  \also\terminal{(} \nonterminal{c-op} \nonterminal{c-expr}\any\terminal{)}\\
\nonterminal{c-op}\is\nonterminal{symbol}\\
\nonterminal{name}\is\nonterminal{symbol}\\
\end{grammar}

Structure definitions provide a way to compute offsets to various elements
within a memory block. They also contain enough information to generate a
corresponding C declaration.

\begin{grammar}
\nonterminal{structure}\is\terminal{(} \terminal{structure}
 \nonterminal{external name}
   \terminal{(}\nonterminal{field}\oneplus\terminal{)}\terminal{)}\\
\nonterminal{field}\is\terminal{(} \nonterminal{external name}
  \nonterminal{type name} \terminal{)}\\
\nonterminal{external name}\is\nonterminal{name} \nonterminal{string}\\
\nonterminal{type name}\is\nonterminal{name}\\
\end{grammar}

Each \nonterminal{structure} definition provides the following set of
\nonterminal{c-expr}. First, there is \terminal{(size-of}
\nonterminal{structure name}\terminal{)} which computes the size
of the structure in bytes. It properly handles all alignment requirements for
parts of the structure and produces the same result as
\verb|sizeof (struct foo)| in C where \verb|foo| is the corresponding C tag.
Second, there is \terminal{(align-of} \nonterminal{structure name}\terminal{)}
computing the alignment of the structure in bytes. It is always a power of 2.
In addition, for each component of the structure, there is 
\terminal{(offset-of} \nonterminal{structure name}
\nonterminal{field name}\terminal{)}, which computes an offset from the
begining of the structure to the given field.

Array types are introduced with the following contruct:
\begin{grammar}
\nonterminal{array}\is\terminal{(} \terminal{array}
 \nonterminal{external name} \nonterminal{base type name}
     \nonterminal{constant expression}\terminal{)}\\
\nonterminal{base type name}\is\nonterminal{type name}
\end{grammar}

There is also a set of predefined types. At this stage we do not specify
them.

Constants, predefined types, arrays, and structures may be aliased. For
simplicity, we do not keep separate name spaces for them. All definitions are
checked for conflicts.
\begin{grammar}
\nonterminal{alias}\is\terminal{(} \terminal{alias}
 \nonterminal{new name} \nonterminal{old name}\terminal{)}\\
\nonterminal{new name}\is\nonterminal{name}\\
\nonterminal{old name}\is\nonterminal{name}\\
\end{grammar}

The last part of the top level structure is procedure. At this time we only
define leaf procedures. Since we need to generate multiple variants of the
procedures from the same sources, external names are generated from the
attributes. The internal names are not used in this version.

\begin{grammar}
\nonterminal{procedure}\is\terminal{(} \terminal{procedure}
  \nonterminal{name} \terminal{(} \nonterminal{attribute}\any \terminal{)}
  \terminal{(} \nonterminal{argument}\any \terminal{)}
  \nonterminal{code}\oneplus \terminal{)}\\
\nonterminal{argument}\is\terminal{(}
    \nonterminal{argument name} \nonterminal{type name}
    \nonterminal{C type} \nonterminal{C name} \terminal{)}\\
\nonterminal{argument name}\is\nonterminal{name}\\
\nonterminal{C type}\is\nonterminal{string}\\
\nonterminal{C name}\is\nonterminal{string}\\
\nonterminal{attribute}\is\nonterminal{name}\\
  \also\terminal{(} \nonterminal{name}
                  \nonterminal{a-value}\oneplus \terminal{)}\\
\nonterminal{a-value}\is\nonterminal{string}\\
   \also\nonterminal{number}\\
   \also\nonterminal{symbol}\\
\end{grammar}

The code is design to help with instruction generation and data flow analysis.
At this stage we keep regular loops and provide conditional branching. There is
no back branches or returns. We do not provide automatic variables since
there are only leaf procedures.

\begin{grammar}
\nonterminal{code}\is \nonterminal{operation}\\
  \also\nonterminal{memory access}\\
  \also\nonterminal{block}\\
  \also\nonterminal{loop}\\
  \also\nonterminal{conditional}\\
  \also\nonterminal{inner macro}\\
\nonterminal{inner macro}\is\terminal{(} \terminal{repeat}
         \terminal{(} \nonterminal{iterator}\any \terminal{)}
         \nonterminal{code}\oneplus \terminal{)}\\
\end{grammar}

Operations modify only their outputs and depends only on their inputs. The
name space of the opcodes is open-ended, the attributes are specific for each
opcode.

\begin{grammar}
\nonterminal{operation}\is\terminal{(} \terminal{op}
  \nonterminal{opcode} \terminal{(} \nonterminal{attribute}\any \terminal{)}
  \terminal{(} \nonterminal{output}\oneplus \terminal{)}
  \terminal{(} \nonterminal{input}\any \terminal{)} \terminal{)}\\
\nonterminal{opcode}\is\nonterminal{name}\\
\nonterminal{output}\is\nonterminal{name}\\
\nonterminal{input}\is\nonterminal{register}\\
    \also \nonterminal{constant expression}\\
\nonterminal{register}\is\terminal{(} \terminal{reg}
    \nonterminal{name} \terminal{)}
\end{grammar}

Memory operations read and write memory. The type of the data is provided
explicitly and is checked for writes (reads define the output which is checked
at use.)

\begin{grammar}
\nonterminal{memory access}\is
  \terminal{(} \terminal{load} \nonterminal{type name}
              \terminal{(} \nonterminal{attribute}\any \terminal{)}
          \nonterminal{output}
          \nonterminal{address} \terminal{)}\\
 \also
  \terminal{(} \terminal{store} \nonterminal{type name}
              \terminal{(} \nonterminal{attribute}\any \terminal{)}
          \nonterminal{address}
          \nonterminal{input} \terminal{)}\\
\nonterminal{address}\is\terminal{(} \nonterminal{input}\oneplus \terminal{)}\\
\end{grammar}

The next is the block. It packages codes together into a single code to
simplify syntax.

\begin{grammar}
\nonterminal{block}\is\terminal{(} \terminal{begin}
  \nonterminal{code}\oneplus \terminal{)}\\
\end{grammar}

The conditional is also simple. We provide two forms. The constant predicates
are handled in the compile time.
\begin{grammar}
\nonterminal{conditional}\is\terminal{(} \terminal{if-else}
  \nonterminal{predicate} \nonterminal{non-zero branch}
                          \nonterminal{zero branch} \terminal{)}\\
 \also \terminal{(} \terminal{if}
  \nonterminal{predicate} \nonterminal{non-zero branch} \terminal{)}\\
\nonterminal{predicate}\is\nonterminal{input}\\
\nonterminal{non-zero branch}\is\nonterminal{code}\\
\nonterminal{zero branch}\is\nonterminal{code}\\
\end{grammar}

The loop construct always runs through a given number of iterations. The
limits are computed once at the beginning of the loop. The loop variable is
of time int and is visible only inside the loop. Unrolling and prefetching
inside the loop is controlled by the attributes. The loop step is alway $1$.

\begin{grammar}
\nonterminal{loop}\is\terminal{(} \terminal{loop}
  \terminal{(} \nonterminal{attribute}\any \terminal{)}
  \terminal{(} \nonterminal{loop variable} \nonterminal{inclusive low}
              \nonterminal{exclusive high} \terminal{)}
  \nonterminal{code}\oneplus \terminal{)}\\
\nonterminal{loop variable}\is\nonterminal{output}\\
\nonterminal{inclusive low}\is\nonterminal{input}\\
\nonterminal{exclusive high}\is\nonterminal{input}\\
\end{grammar}

It is possible to use quare brackets [[[]]] instead if parentheses [[()]] in
any place as long as the closing backet matches the open one.
Also, [[;]] starts a commnet upto the end of line.

\section{PARSING}
Function [[parse-qa0]] converts the surface syntax into an abstract syntax tree.
Checks are done at this stage, but since we use Scheme's [[read]], error
reporting does not include line numbers.

<<File [[parser.ss]]>>=
<<Abstract syntax tree definitions>>
(define (parse-qa0-file file-name)
  <<Parser helpers>>
  (let ([f (open-input-file file-name)])
    (let loop ([s-expr (read f)] [ast (empty-ast)])
      (cond
        [(eof-object? s-expr) ast]
        [else (loop (read f) (parse-top s-expr ast))]))))
@

\subsection{AST definitions}
Definitions of the abstract syntax tree mirror the grammar.
<<Abstract syntax tree definitions>>=
(define-variant qa0-top (decl*))
(define-variant qa0-alias (old-name new-name))
(define-variant qa0-const (name value))
(define-variant qa0-struct (name c-name
                            field-name*
                            field-type*
                            field-c-name*))
(define-variant qa0-array (name c-name base-name size))
(define-variant qa0-proc (attribute*
                          name
                          arg-name*
                          arg-type*
                          arg-c-name*
                          arg-c-type*
                          code*))
(define-variant qa0-repeat-list (id value* body*))
(define-variant qa0-repeat-range (id low high body*))
@

Here are codes:
<<Abstract syntax tree definitions>>=
(define-variant qa0-operation (attribute* name output* input*))
(define-variant qa0-load (attribute* type output addr*))
(define-variant qa0-store (attribute* type addr* value))
(define-variant qa0-loop (attribute* var low high code*))
(define-variant qa0-if (var true-code* false-code*))
(define-variant qa0-macro-list (id value* code*))
(define-variant qa0-macro-range (id low high code*))
@

The attributes:
<<Abstract syntax tree definitions>>=
(define-variant qa0-attribute (name value*))
@

Constant expressions and registers:
<<Abstract syntax tree definitions>>=
(define-variant c-expr-id (id))
(define-variant c-expr-number (number))
(define-variant c-expr-string (string))
(define-variant c-expr-op (name c-expr*))
(define-variant reg (name))
@

\subsection{Parser helpers}
In many places a list is expected. Here we check that a list is
provided indeed.
<<Parser helpers>>=
(define (check-list msg in cmp min-size)
  (if (not (list? in))
      (error 'parse-qa0 "List expected in ~a, found~%  ~a~%"
             msg in))
  (if (not (cmp (length in) min-size))
      (error 'parse-qa0
             "List of ~a ~a is expected in ~a, found:~%   ~a~%"
             (if (eq? cmp =) "exactly" "at least")
             min-size msg in)))
@
We also often check if something is a name:
<<Parser helpers>>=
(define (check-name msg form name)
  (if (not (symbol? name))
      (error 'parse-qa0
             "Expecting name for ~a, found ~a in:~%~a~%"
             msg name form)))
@
and that something is a string:
<<Parser helpers>>=
(define (check-string msg form string)
  (if (not (string? string))
      (error 'parse-qa0
             "Expecting string for ~a, found ~a in:~%~a~%"
             msg string form)))
@

Checking the syntax of the attribute
<<Parser helpers>>=
(define (check-attrib* msg form attr*)
  (for-each (lambda (attr) (check-attrib msg form attr)) attr*))
(define (check-attrib msg form attr)
  (if (not (or (symbol? attr)
               (and (list? attr)
                    (>= (length attr) 1)
                    (symbol? (car attr)))))
      (error 'parse-qa0 "Expecting attribute for ~a, found ~a in~%~a~%"
             msg attr form)))
@

Each output is a symbol:
<<Parser helpers>>=
(define (check-output* msg form out*)
  (cond
    [(null? out*) #t]
    [(not (symbol? (car out*)))
       (error 'parse-qa0 "Bad value for output of ~a, found ~a in~%~a~%"
               msg (car out*) form)]
    [else (check-output* msg form (cdr out*))]))
@

Each input is either a constant or a register:
<<Parser helpers>>=
(define (check-input* msg form in*)
  (for-each (lambda (in) (check-input msg form in)) in*))
(define (check-input msg form in)
  (check-list msg in = 2)
  (if (case (car in)
        [(reg) (not (symbol? (cadr in)))]
        [(const) #f]
        [else #t])
      (error 'parse-qa0 "Bad value for input of ~a, found ~a in ~%~a~%"
             msg in form)))
@
There are two iterator forms:
<<Parser helpers>>=
(define (check-iterator msg form iter)
   (check-list msg iter >= 2)
   (check-name msg form (car iter))
   (case (length iter)
     [(2) (check-list "iterator range" (cadr iter) >= 0)]
     [(3) #t]
     [else (error 'parse-qa0 "Bad iterator form of ~a, found ~a in~%~a~%"
                  msg iter form)]))
@

We start with an empty AST. It is a valid input, by the way:
<<Parser helpers>>=
(define (empty-ast) (make-qa0-top '()))
@

Add another top-level form:
<<Parser helpers>>=
(define (parse-top s-expr ast)
   (check-list "top level" s-expr >= 1)
   (variant-case ast
     [qa0-top (decl*)
       (case (car s-expr)
         <<Recognize top-level forms>>
         [else (error 'parse-qa0 "Unknown form:~%~a~%" s-expr)])]))
@

<<Recognize top-level forms>>=
[(alias) (make-qa0-top (append decl* (list (parse-alias s-expr))))]
@
<<Parser helpers>>=
(define (parse-alias s-expr)
  (check-list "top level alias" s-expr = 3)
  (check-name "alias new name" s-expr (cadr s-expr))
  (check-name "alias old name" s-expr (caddr s-expr))
  (make-qa0-alias (caddr s-expr) (cadr s-expr)))
@

<<Recognize top-level forms>>=
[(constant) (make-qa0-top (append decl* (list (parse-constant s-expr))))]
@
<<Parser helpers>>=
(define (parse-constant s-expr)
  (check-list "constant" s-expr = 3)
  (check-name "constant name" s-expr (cadr s-expr))
  (make-qa0-const (cadr s-expr) (parse-const-expr (caddr s-expr))))
@

<<Recognize top-level forms>>=
[(array) (make-qa0-top (append decl* (list (parse-array s-expr))))]
@
<<Parser helpers>>=
(define (parse-array s-expr)
  (check-list "array" s-expr = 5)
  (check-name "array name" s-expr (cadr s-expr))
  (check-string "array c-name" s-expr (caddr s-expr))
  (check-name "array base name" s-expr (cadddr s-expr))
  (make-qa0-array (cadr s-expr) (caddr s-expr) (cadddr s-expr)
                  (parse-const-expr (car (cddddr s-expr)))))
@

<<Recognize top-level forms>>=
[(structure) (make-qa0-top (append decl* (list (parse-structure s-expr))))]
@
<<Parser helpers>>=
(define (parse-structure s-expr)
  (check-list "structure" s-expr = 4)
  (let ([name (cadr s-expr)]
        [c-name (caddr s-expr)]
        [f* (cadddr s-expr)])
    (check-name "struct name" s-expr name)
    (check-string "struct c-name" s-expr c-name)
    (map (lambda (f)
            (check-list "struct field" f = 3)
            (check-name "struct field name" s-expr (car f))
            (check-string "struct field c-name" s-expr (cadr f))
            (check-name "struct field type" s-expr (caddr f)))
         f*)
    (make-qa0-struct name c-name (map car f*) (map caddr f*) (map cadr f*))))
@

<<Recognize top-level forms>>=
[(repeat procedure) (make-qa0-top (append decl* (parse-repeat s-expr)))]
@
<<Parser helpers>>=
(define (parse-repeat s-expr)
  (check-list "top level repeat" s-expr >= 1)
  (case (car s-expr)
    [(repeat)
       (check-list "top level repeat" s-expr >= 3)
       (let loop ([bind* (cadr s-expr)])
         (cond
           [(null? bind*) (let do-body ([p* '()] [b* (cddr s-expr)])
                            (cond
                              [(null? b*) p*]
                              [else (do-body (append p* (parse-repeat (car b*)))
                                             (cdr b*))]))]
           [else (check-iterator "top level repeat" s-expr (car bind*))
             (list
               (case (length (car bind*))
                 [(2) (make-qa0-repeat-list (caar bind*)
                                            (map parse-a-value (cadar bind*))
                                            (loop (cdr bind*)))]
                 [(3) (make-qa0-repeat-range (caar bind*)
                                             (parse-const-expr (cadar bind*))
                                             (parse-const-expr (caddar bind*))
                                             (loop (cdr bind*)))]
                 [else (error 'qa0 "Internal error in parse-repeat")]))]))]
    [(procedure) (list (parse-procedure s-expr))]
    [else (error 'qa0 "Bad form at top level~%~a~%" s-expr)]))
@

Parsing an a-value is trivial:
<<Parser helpers>>=
(define (parse-a-value expr)
   (if (or (number? expr)
           (symbol? expr)
           (string? expr)) expr
       (error 'parse-qa0 "a-value is not ~a~%" expr)))
@

<<Parser helpers>>=
(define (parse-procedure s-expr)
   (check-list "procedure" s-expr >= 5)
   (check-name "procedure name" s-expr (cadr s-expr))
   (check-attrib* "procedure attributes" s-expr (caddr s-expr))
   (check-list "procedure arguments" (cadddr s-expr) >= 0)
   (map (lambda (arg)
          (check-list "procedure argument" arg = 4)
          (check-name "argument name" arg (car arg))
          (check-name "argument type" arg (cadr arg))
          (check-string "argument c-name" arg (caddr arg))
          (check-string "argument c-type" arg (cadddr arg)))
        (cadddr s-expr))
   (parse-code* (cddddr s-expr)
                (lambda (code*)
                  (make-qa0-proc (map parse-attribute (caddr s-expr))
                                 (cadr s-expr)
                                 (map car (cadddr s-expr))
                                 (map cadr (cadddr s-expr))
                                 (map caddr (cadddr s-expr))
                                 (map cadddr (cadddr s-expr))
                                 code*))))
@
Parse a list of codes flattening blocks.
<<Parser helpers>>=
(define (parse-code* code* k)
   (if (null? code*) (k '())
       (parse-code* (cdr code*)
         (lambda (op*)
           (let ([code (car code*)])
             (check-list "operation" code >= 1)
             (case (car code)
               [(begin) (parse-code* (cdr code)
                                     (lambda (op2*) (k (append op2* op*))))]
               [(macro) (k (parse-macro code op*))]
               [else (k (cons (parse-code code) op*))]))))))
@

Attribute may be without values or it can contain a list of a-values:
<<Parser helpers>>=
(define (parse-attribute f)
   (cond
    [(symbol? f) (make-qa0-attribute f '())]
    [else (check-list "attribute" f >= 1)
       (make-qa0-attribute (car f) (map parse-a-value (cdr f)))]))
@

Parsing a code element dispatches on the [[car]]:
<<Parser helpers>>=
(define (parse-code f)
  (check-list "code" f >= 1)
  (case (car f)
    <<Recognize code forms>>
    [else (error 'parse-qa0 "Unexpected code~%~a~%" f)]))
@

Let us start with an [[op]]:
<<Recognize code forms>>=
[(op) (parse-op f)]
@
<<Parser helpers>>=
(define (parse-op f)
  (check-list "code op" f = 5)
  (let ([name (cadr f)]
        [attr* (caddr f)]
        [out* (cadddr f)]
        [in* (car (cddddr f))])
    (check-name "code op name" f name)
    (check-attrib* "code op attirbutes" f attr*)
    (check-output* "code op outputs" f out*)
    (check-input* "code op inputs" f in*)
    (make-qa0-operation (map parse-attribute attr*)
                        name
                        (map parse-output out*)
                        (map parse-input in*))))
@
<<Parser helpers>>=
(define (parse-output out) (parse-reg out))
@
<<Parser helpers>>=
(define (parse-input in)
  (case (car in)
    [(reg) (parse-reg (cadr in))]
    [(const) (parse-const-expr in)]
    [else (error 'parse-qa0 "Internal error in parse-input")]))
@

All input registers are prefixed with [[_]]. Other prefixed will be used for
generated registers.
<<Parser helpers>>=
(define (parse-reg name)
  (make-reg (string->symbol (format "_~a" name))))
@

<<Recognize code forms>>=
[(load) (parse-load f)]
@
<<Parser helpers>>=
(define (parse-load f)
  (check-list "load" f = 5)
  (let ([type (cadr f)]
        [attr* (caddr f)]
        [out (cadddr f)]
        [addr (car (cddddr f))])
    (check-attrib* "load" f attr*)
    (check-name "load" f type)
    (check-output* "load" f (list out))
    (check-input* "load" f addr)
    (make-qa0-load (map parse-attribute attr*)
                   type
                   (parse-output out)
                   (map parse-input addr))))
@

<<Recognize code forms>>=
[(store) (parse-store f)]
@
<<Parser helpers>>=
(define (parse-store f)
  (check-list "store" f = 5)
  (let ([type (cadr f)]
        [attr* (caddr f)]
        [addr (cadddr f)]
        [value (car (cddddr f))])
    (check-attrib* "store" f attr*)
    (check-name "store" f type)
    (check-input* "store" f addr)
    (check-input "store" f value)
    (make-qa0-store (map parse-attribute attr*)
                    type
                    (map parse-input addr)
                    (parse-input value))))
@

<<Recognize code forms>>=
[(loop) (parse-loop f)]
@
<<Parser helpers>>=
(define (parse-loop f)
  (check-list "loop" f >= 4)
  (let ([attr* (cadr f)]
        [ctl (caddr f)]
        [code* (cdddr f)])
    (check-attrib* "loop" f attr*)
    (check-list "loop control" ctl = 3)
    (parse-code* code*
      (lambda (op*)
        (make-qa0-loop (map parse-attribute attr*)
                       (parse-output (car ctl))
                       (parse-input (cadr ctl))
                       (parse-input (caddr ctl))
                       op*)))))
@

<<Recognize code forms>>=
[(if) (parse-if f)]
@
<<Parser helpers>>=
(define (parse-if f)
  (check-list "if" f = 3)
  (let ([c (cadr f)]
        [t (caddr f)])
    (check-input "if predicate" f c)
    (check-list "if branch" t)
    (parse-code* t
      (lambda (t*) (make-qa0-if (parse-input c) t* '())))))
@

<<Recognize code forms>>=
[(if-else) (parse-if-else f)]
@
<<Parser helpers>>=
(define (parse-if-else form)
  (check-list "if-else" form = 4)
  (let ([c (cadr form)]
        [t (caddr form)]
        [f (cadddr form)])
    (check-input "if-else predicate" form c)
    (check-list "if-else true branch" t)
    (check-list "if-else false branch" f)
    (parse-code* t
      (lambda (t*)
        (parse-code* f
          (lambda (f*) (make-qa0-if (parse-input c) t* f*)))))))
@

<<Parser helpers>>=
(define (parse-macro form op*)
  (check-list "macro" form >= 3)
  (let ([iterator* (cadr form)]
        [code* (cddr form)])
    (let loop ([i* iterator*] [t* op*])
      (cond
        [(null? i*) (parse-code* code* (lambda (c*) (append c* t*)))]
        [else (let ([i (car i*)] [i* (cdr i*)])
                (check-iterator "macro" form i)
                (case (length i)
                  [(2) (let ([c* (loop i* '())]
                             [v* (map parse-a-value (cadr i))]
                             [id (car i)])
                         (append (make-qa0-macro-list id v* c*) t*))]
                  [(3) (let ([c* (loop i* '())]
                             [id (car i)]
                             [lo (parse-const-expr (cadr i))]
			     [hi (parse-const-expr (caddr i))])
                         (append (make-qa0-macro-range id lo hi c*) t*))]
                  [else (error 'qa0 "Internal error in parse-macro")]))]))))
@

Finally, the constant expressions:
<<Parser helpers>>=
(define (parse-const-expr form)
  (check-list "constant expression" form = 2)
  (parse-c-expr (cadr form)))
(define (parse-c-expr form)
  (cond
    [(number? form) (make-c-expr-number form)]
    [(symbol? form) (make-c-expr-id form)]
    [(string? form) (make-c-expr-string form)]
    [(and (list? form) (>= (length form) 1) (symbol? (car form)))
     (make-c-expr-op (car form) (map parse-c-expr (cdr form)))]
    [else (error 'parse-qa0 "constant expression is bad:~%~a~%" form)]))
@
\section{CONSTANT FOLDING}
This pass computes all constant expressions and expands the macros. Constant
conditional are also handled at this stage as well as other constant operations.
File [[cfolding.ss]] should be loaded after [[parser.ss]]. It defines
one function, [[fold-constants]] that convers [[qa0-top]] into [[qa0-top]]. The
returned value has constants only of the form [[(const N)]] where [[N]] is a
number.
<<File [[cfolding.ss]]>>=
<<Folding environment routines>>
(define (fold-constants/env ast machine real)
  <<Folding helpers>>
  (variant-case ast
    [qa0-top (decl*)
       (let loop ([in* decl*] [out* '()] [env (ce-start-env machine real)])
         (cond
           [(null? in*) (values (make-qa0-top (reverse out*)) env)]
           [else (let-values* ([(out* env) (cf-decl (car in*) out* env)])
                   (loop (cdr in*) out* env))]))]))
(define (fold-constants ast machine real)
  (let-values* ([(ast env) (fold-constants/env ast machine real)])
    ast))
@
The [[machine]] is a procedure that adds definitions of [[int]], [[double]],
[[float]], [[pointer]], [[verctor-float]], and [[vector-double]] to the
environment passed as an argument. It returns a new environment.
<<Folding helpers>>=
(define (ce-start-env machine real)
  (let* ([env (ce-empty-env)]
         [env (machine env)])
    (case real
      [(double) (let* ([env (ce-add-alias env 'REAL    'double)]
                       [env (ce-add-alias env 'COMPLEX 'complex-double)]
                       [env (ce-add-alias env 'VECTOR  'vector-double)])
                  env)]
      [(float) (let* ([env (ce-add-alias env 'REAL    'float)]
                      [env (ce-add-alias env 'COMPLEX 'complex-float)]
                      [env (ce-add-alias env 'VECTOR  'vector-float)])
                 env)]
      [else (error 'fold-constant "Bad value of REAL: ~a" real)])))
@
<<Folding environment routines>>=
(define (ce-empty-env) '())
@

We rebuild the AST while walking though it.
<<Folding helpers>>=
(define (cf-decl ast out* env)
  (variant-case ast
    [qa0-alias (old-name new-name) (cf-alias old-name new-name out* env)]
    [qa0-const (name value) (cf-const name value out* env)]
    [qa0-struct (name c-name field-name* field-type* field-c-name*)
        (cf-struct name c-name field-name* field-type* field-c-name* out* env)]
    [qa0-array (name c-name base-name size)
        (cf-array name c-name base-name size out* env)]
    [qa0-proc (attribute* name arg-name* arg-type* arg-c-name* arg-c-type*
               code*)
       (cf-proc attribute* name arg-name* arg-type* arg-c-name* arg-c-type*
                code* out* env)]
    [qa0-repeat-list (id value* body*)
       (cf-repeat-list id value* body* out* env)]
    [qa0-repeat-range (id low high body*)
       (cf-repeat-range id low high body* out* env)]))
@

Aliases are removed after updating the environment.
<<Folding helpers>>=
(define (cf-alias old new out* env)
  (values out* (ce-add-alias env new old)))
@

Constants are also removed at this stage.
<<Folding helpers>>=
(define (cf-const name value out* env)
  (let ([v (cf-eval-const value env)])
    (values out* (ce-add-const env name v))))
@

We keep structures and arrays as they are needed to produce a header file.
<<Folding helpers>>=
(define (cf-struct name c-name field-name* field-type* field-c-name* out* env)
  (values (cons (make-qa0-struct name c-name
                                 field-name* field-type* field-c-name*)
                out*)
          (ce-add-struct env name c-name field-name* field-type*)))
(define (cf-array name c-name base size out* env)
  (let ([size (cf-eval-const size env)])
    (values (cons (make-qa0-array name c-name base (cf-rewrap size)) out*)
            (ce-add-array env name c-name base size))))
@
In procedures we fold instructions. Care should be taken of loops and
conditionals, as they may expand into a sequence of instructions.
<<Folding helpers>>=
(define (cf-proc attribute* name arg-name* arg-type* arg-c-name* arg-c-type*
                 code* out* env)
  (values (cons (make-qa0-proc (cf-attribute* attribute* env)
                               name
                               arg-name*
                               arg-type*
                               arg-c-name*
                               arg-c-type*
                               (cf-code* code* '() env))
                out*)
          env))
@

List repeats do not evaluate literals.
<<Folding helpers>>=
(define (cf-repeat-list id value* body* out* env)
  (let loop-values ([value* value*] [out* out*])
    (cond
      [(null? value*) (values out* env)]
      [else (let ([env-x (ce-add-const env id (car value*))])
              (let loop-body ([body* body*] [out* out*])
                (cond
                  [(null? body*) (loop-values (cdr value*) out*)]
                  [else (loop-body (cdr body*)
                                   (cf-repeat (car body*) out* env-x))])))])))
@
On the other hand, a range repeat evaluates both ranges:
<<Folding helpers>>=
(define (cf-repeat-range id low high body* out* env)
  (let ([low (cf-eval-const low env)]
        [high (cf-eval-const high env)])
    (let loop-values ([i low] [out* out*])
      (cond
       [(>= i high) (values out* env)]
       [else (let ([env-x (ce-add-const env id i)])
               (let loop-body ([body* body*] [out* out*])
                 (cond
                   [(null? body*) (loop-values (+ i 1) out*)]
                   [else (loop-body (cdr body*)
                                    (cf-repeat (car body*) out* env-x))])))]))))
@

<<Folding helpers>>=
(define (cf-repeat ast out* env)
   (let-values* ([(out* env)
       (variant-case ast
         [qa0-proc (attribute* name arg-name* arg-type* arg-c-name* arg-c-type*
                    code*)
            (cf-proc attribute* name arg-name* arg-type* arg-c-name* arg-c-type*
                     code* out* env)]
         [qa0-repeat-list (id value* body*)
            (cf-repeat-list id value* body* out* env)]
         [qa0-repeat-range (id low high body*)
            (cf-repeat-range id low high body* out* env)])])
      out*))
@

For the attributes the values are weakly substituted with literals.
<<Folding helpers>>=
(define (cf-attribute attribute env)
  (variant-case attribute
    [qa0-attribute (name value*)
      (make-qa0-attribute name
                          (map (lambda (v) (cf-eval-literal v env)) value*))]))
(define (cf-attribute* attribute* env)
  (map (lambda (attr) (cf-attribute attr env)) attribute*))
@

Finally, the code.
<<Folding helpers>>=
(define (cf-code code out* env)
  (variant-case code
    [qa0-operation (attribute* name output* input*)
       (cf-operation attribute* name output* input* out* env)]
    [qa0-load (attribute* type output addr*)
       (cf-load attribute* type output addr* out* env)]
    [qa0-store (attribute* type addr* value)
       (cf-store attribute* type addr* value out* env)]
    [qa0-loop (attribute* var low high code*)
       (cf-loop attribute* var low high code* out* env)]
    [qa0-if (var true-code* false-code*)
       (cf-if var true-code* false-code* out* env)]
    [qa0-macro-list (id value* code*)
       (cf-macro-list id value* code* out* env)]
    [qa0-macro-range (id low high code*)
       (cf-macro-range id low high code* out* env)]))
@
In the conditional we first evaluate the control expression and if it is a
constant, eliminate the unreacheable code.
<<Folding helpers>>=
(define (cf-if var true* false* out* env)
  (let ([var (cf-input var env)])
    (variant-case var
      [qa0-const (value) (if (zero? value) (cf-code* false* out* env)
                             (cf-code* true* out* env))]
      [reg (name) (cons (make-qa0-if var
                                     (cf-code* true* '() env)
                                     (cf-code* false* '() env))
                        env)])))
@

<<Folding helpers>>=
(define (cf-code* code* out* env)
  (let loop ([code* code*] [out* out*])
    (cond
      [(null? code*) (reverse out*)]
      [else (loop (cdr code*) (cf-code (car code*) out* env))])))
@

In [[operation]], we evaluate attributes and inputs. We may extend constant
folding later to [[name]] and [[output*]].
<<Folding helpers>>=
(define (cf-operation attribute* name output* input* out* env)
  (cons (make-qa0-operation (cf-attribute* attribute* env)
                            name
                            output*
                            (cf-input* input* env))
        out*))
@
Memory accesses are similar:
<<Folding helpers>>=
(define (cf-load attribute* type output addr* out* env)
  (cons (make-qa0-load (cf-attribute* attribute* env)
                       type
                       output
                       (cf-addr* addr* env))
        out*))
@

<<Folding helpers>>=
(define (cf-store attribute* type addr* value out* env)
  (cons (make-qa0-store (cf-attribute* attribute* env)
                       type
                       (cf-addr* addr* env)
                       (cf-input value env))
        out*))
@

In [[loop]] only limits and the body are folded. We do not do loop unrolling
here.
<<Folding helpers>>=
(define (cf-loop attribute* var low high code* out* env)
   (cons (make-qa0-loop (cf-attribute* attribute* env)
                        var
                        (cf-input low env)
                        (cf-input high env)
                        (cf-code* code* '() env))
         out*))
@

For [[macros]] the folding is similar to repeats, but we are dealing with
[[code]] inside.
<<Folding helpers>>=
(define (cf-macro-list id value* code* out* env)
  (let loop ([value* value*] [out* out*])
    (cond
      [(null? value*) out*]
      [else (let ([env-x (ce-add-const env id (car value*))])
              (loop (cdr value*) (cf-code* code* out* env-x)))])))
@
<<Folding helpers>>=
(define (cf-macro-range id low high code* out* env)
   (let ([low (cf-eval-const low env)]
         [high (cf-eval-const high env)])
     (let loop ([i low] [out* out*])
       (cond
         [(>= i high) out*]
         [else (loop (+ i 1) (cf-code* code* out*
                                       (ce-add-const env id i)))]))))
@
Addresses are just inputs.
<<Folding helpers>>=
(define (cf-addr* addr* env) (map (lambda (addr) (cf-input addr env)) addr*))
@

Inputs are trivial:
<<Folding helpers>>=
(define (cf-input* input* env) (map (lambda (in) (cf-input in env)) input*))
@

An input is either [[reg]] or [[const]]:
<<Folding helpers>>=
(define (cf-input input env)
  (variant-case input
    [reg () input]
    [else (cf-rewrap (cf-eval-const input env))]))
(define (cf-rewrap c)
    (cond
      [(number? c) (make-c-expr-number c)]
      [(string? c) (make-c-expr-string c)]
      [else (error 'qa0 "Unexpected computed constant is ~a" c)]))
@

Evaluation of constant should find all [[c-expr-id]] with appropriate values.
<<Folding helpers>>=
(define (cf-eval-const const env)
  (variant-case const
    [c-expr-op (name c-expr*) (cx-const-op name c-expr* env)]
    [c-expr-string (string) string]
    [c-expr-number (number) number]
    [c-expr-id (id) (ce-lookup env (list 'const id)
                                   "Constant evaluation of ~a" id)]))
@

Literals may stand for themselves, so their evaluation is weaker:
<<Folding helpers>>=
(define (cf-eval-literal literal env)
  (ce-search env (list 'const literal) (lambda (x) x) (lambda () literal)))
@
\subsection{Constant computation}
<<Folding helpers>>=
(define (cx-const-op name expr* env)
  <<Arithmetic helpers>>
  (case name
    [(size-of align-of) (check-id-arg* expr* 1)
                        (let ([type (get-id (car expr*))])
                          (ce-lookup env (list name type)
                                     "Computing (~a ~a)" name type))]
    [(offset-of) (check-id-arg* expr* 2)
                 (let ([type (get-id (car expr*))]
                       [field (get-id (cadr expr*))])
                   (ce-lookup env (list name type field)
                              "Computing (~a ~a ~a)" name type field))]
    [(+) (compute-arith +)]
    [(-) (compute-arith -)]
    [(*) (compute-arith *)]
    [else (error 'qa0 "Unexpected constant operation ~a" name)]))
@

<<Arithmetic helpers>>=
(define (check-id-arg v)
  (variant-case v
    [c-expr-id () #t]
    [else (error 'qa0 "Expecting id, found ~a" v)]))
(define (check-id-arg* arg* len)
  (if (not (and (list? arg*)
                (= (length arg*) len)))
      (error 'qa0 "Expecting a list of ~a arguments, found ~a" len arg*)
      (let loop ([arg* arg*])
        (cond
          [(null? arg*) #t]
          [else (check-id-arg (car arg*))
                (loop (cdr arg*))]))))
@

<<Arithmetic helpers>>=
(define (get-id v)
  (variant-case v
    [c-expr-id (id) id]))
@

Computation of arithmetic expressions:
<<Arithmetic helpers>>=
(define (compute-arith op)
  (let ([arg* (map (lambda (arg) (cf-eval-const arg env)) expr*)])
    (map check-number-arg arg*)
    (apply op arg*)))
@
<<Arithmetic helpers>>=
(define (check-number-arg arg)
  (if (not (number? arg))
      (error 'qa0 "A number is expected, found ~a" arg)))
@

\subsection{Constant folding environment manipulation}
Environment search continues in one of its continuation:
<<Folding environment routines>>=
(define (ce-search env key k-found k-missed)
  (let ([x (assoc key env)])
    (if x (k-found (cdr x))
        (k-missed))))
@

The [[ce]] lookup routines either returns the associated value or reports an
error.
<<Folding environment routines>>=
(define (ce-lookup env key msg . args)
  (ce-search env key (lambda (x) x)
             (lambda () (apply error 'qa0 msg args))))
(define (ce-lookup-x env type key msg . args)
  (ce-search env `(,type ,key) (lambda (x) x)
             (lambda () (apply error 'qa0 msg args))))
@

<<Folding environment routines>>=
(define (ce-bind env k v) `((,k . ,v) ,@env))
(define (ce-bind-x env t k v) `(((,t ,k) . ,v) ,@env))
@

<<Folding environment routines>>=
(define (ce-add-const env name value)
  (let* ([t (list 'type name)]
         [x (assoc t env)])
    (cond
      [x (error 'qa0 "Rebinding ~a to ~a is not allowed, old binding ~a"
                      name value (cdr x))]
      [else (let* ([env (ce-bind env t 'const)]
                   [env (ce-bind-x env 'const name value)])
              env)])))
@

<<Folding environment routines>>=
(define (ce-add-type env name c-name size align)
  (let* ([t (list 'type name)]
         [x (assoc t env)])
    (cond
      [x (error 'qa0 "Redefining type ~a is not allowed" name)]
      [else (let* ([env (ce-bind env t 'type)]
                   [env (ce-bind-x env 'size-of name size)]
                   [env (ce-bind-x env 'align-of name align)]
                   [env (ce-bind-x env 'components name '())]
                   [env (ce-bind-x env 'name-of name c-name)])
              env)])))
@
<<Folding environment routines>>=
(define (ce-add-array env name c-name base size)
  (let* ([bs (ce-lookup-x env 'size-of base "Size of array base ~a" base)]
         [ba (ce-lookup-x env 'align-of base
	                "Alignment of array base ~a" base)]
         [t (list 'type name)]
         [x (assoc t env)])
    (cond
      [x (error 'qa0 "Redefining array ~a is not allowed" name)]
      [else (let* ([env (ce-bind env t 'array)]
                   [env (ce-bind-x env 'size-of name (* size bs))]
                   [env (ce-bind-x env 'align-of name ba)]
                   [env (ce-bind-x env 'components name '())]
                   [env (ce-bind-x env 'name-of name c-name)])
              env)])))
@
<<Folding environment routines>>=
(define (ce-add-struct env name c-name field* type*)
   (let* ([t (list 'type name)]
          [x (assoc t env)])
     (cond
       [x (error 'qa0 "Redefining structure ~a is not allowed" name)]
       [else (let loop ([env env] [f* field*] [t* type*]
                        [size 0] [align 1])
               (cond
                 [(null? f*)
                   <<Finish structure construction>>
                   ]
                 [else
                   <<Insert next field and loop>>
                   ]))])))
@
<<Finish structure construction>>=
(let* ([env (ce-bind-x env 'type name 'struct)]
       [env (ce-bind-x env 'size-of name size)]
       [env (ce-bind-x env 'align-of name align)]
       [env (ce-bind-x env 'components name field*)]
       [env (ce-bind-x env 'name-of name c-name)])
  env)
@

<<Insert next field and loop>>=
(let* ([f (car f*)] [t (car t*)]
       [a-f (ce-lookup-x env 'align-of t "Alignment of ~a.~a" name f)]
       [s-f (ce-lookup-x env 'size-of t "Size of field ~a.~a" name f)]
       [start (* a-f (quotient (+ size a-f -1) a-f))]
       [align (max a-f align)]
       [env (ce-bind env (list 'offset-of name f) start)])
  (loop env (cdr f*) (cdr t*) (+ start s-f) align))
@

<<Folding environment routines>>=
(define (ce-add-alias env new old)
   (let ([t (ce-lookup-x env 'type old "type of ~a" old)])
     (case t
       [(const) (let* ([v (ce-lookup-x env 'const old "value of ~a" old)]
                       [env (ce-bind-x env 'type new t)]
                       [env (ce-bind-x env 'const new v)])
                  env)]
       [(type array struct)
           (let* ([c (ce-lookup-x env 'components old
                                "components of ~a" old)]
                  [s (ce-lookup-x env 'size-of old "size of ~a" old)]
                  [a (ce-lookup-x env 'align-of old "align of ~a" old)]
                  [x (ce-lookup-x env 'name-of old "C name of ~a" old)]
                  [env (ce-bind-x env 'type new t)]
                  [env (ce-bind-x env 'size-of new s)]
                  [env (ce-bind-x env 'align-of new a)]
                  [env (ce-bind-x env 'components new c)]
                  [env (ce-bind-x env 'name-of new x)])
              (let loop ([c c] [env env])
                (cond
                  [(null? c) env]
                  [else (let ([o (ce-lookup env (list 'offset-of old (car c))
                                                "offset of ~a in ~a"
                                                (car c) old)])
                          (loop (cdr c)
                                (ce-bind env (list 'offset-of new (car c))
                                         o)))])))]
       [else (error 'qa0 "Internal error in ce-add-alias")])))
@

\section{BG/L}
The machine settings for BG/L:
<<Folding environment routines>>=
(define (ce-bgl env)
  (let* ([env (ce-add-type env 'int            "int"             4  4)]
         [env (ce-add-type env 'pointer        "void *"          4  4)]
         [env (ce-add-type env 'float          "float"           4  4)]
         [env (ce-add-type env 'double         "double"          8  8)]
         [env (ce-add-type env 'vector-float   "vector float"    8  8)]
         [env (ce-add-type env 'vector-double  "vector double"  16 16)]
         [env (ce-add-type env 'complex-float  "complex float"   8  8)]
         [env (ce-add-type env 'complex-double "complex double" 16 16)]
         [env (ce-add-const env '*colors*       3)]
         [env (ce-add-const env '*DIM*          4)]
         [env (ce-add-const env '*fermion-dim*  4)])
     env))
@

\section{MACROS}
Useful macros for R5RS with [[syntax-case]]. First, progress reporting:
<<File [[common.ss]]>>=
(define *verbose?* #f)
(define (progress-report fmt . args)
  (if *verbose?*
      (begin (printf "  ")
             (apply printf format args)
             (printf "...~%")
             (flush-output-port (current-output-port)))))
@
Also, my favorite debugging procedure
<<File [[common.ss]]>>=
(define (dbg . msg)
   (display "D:")
   (for-each (lambda (x) (display " ") (write x)) msg)
   (newline)
   #f)
@
Next, assertions.
<<File [[common.ss]]>>=
(define-syntax assert
  (lambda (x)
    (syntax-case x ()
      [(_ test fmt arg ...)
       (syntax (if (not test) (error 'assert (string-append "FAILED: " fmt)
                                     arg ...)))])))
@
For [[define-variant]] we need to be able to inject new names into the current
lexical environment. The code below does the Right Thing.
<<File [[common.ss]]>>=
(define-syntax define-variant
  (lambda (x)
    <<Define [[mk-name]]>>
    (syntax-case x ()
      [(_ name (field ...))
       (with-syntax (
          <<Injected names for [[define-syntax]]>>
         )
         (with-syntax
           ([(index ...) (let f ([i 1])
                            (if (= i (syntax-object->datum (syntax count))) '()
                                (cons i (f (+ 1 i)))))])
           (syntax
             (begin
               <<[[variant]] definitions>>
             ))))])))
@

<<Define [[mk-name]]>>=
(define (mk-name template-id . args)
  (datum->syntax-object template-id
    (string->symbol (apply string-append
                           (map (lambda (x)
                                  (if (string? x) x
                                      (symbol->string (syntax-object->datum x))))
                                args)))))
@
Now define the names used by [[variant]]:
<<Injected names for [[define-syntax]]>>=
[constructor (mk-name (syntax name) 'make- (syntax name))]
[predicate (mk-name (syntax name) (syntax name) '?)]
[(reader ...) (map (lambda (field)
                     (mk-name (syntax name) (syntax name) "->" field))
                   (syntax (field ...)))]
[count (length (syntax (name field ...)))]
@

Finally, we can expand a new [[variant]] into corresponding defintions:
<<[[variant]] definitions>>=
(define constructor (lambda (field ...) (vector 'name field ...)))
(define predicate (lambda (object)
                    (and (vector? object)
                         (= (vector-length object) count)
                         (eq? (vector-ref object 0) 'name))))
(define reader (lambda (object) (vector-ref object index))) ...
@

Here is a generic variant discriminator:
<<File [[common.ss]]>>=
(define variant-type (lambda (variant) (vector-ref variant 0)))
@

These variants are very useful with the [[variant-case]]:
<<File [[common.ss]]>>=
(define-syntax variant-case
  (lambda (x)
    <<Define [[mk-name]]>>
    (syntax-case x (else)
      [(_ exp clause ...) (not (identifier? (syntax exp)))
          (syntax (let ([var exp]) (_ var clause ...)))]
      [(_ var) (syntax (error 'variant-case "no clause matches ~a" var))]
      [(_ var (else exp exp1 ...)) (syntax (begin exp exp1 ...))]
      [(_ var (name [(fname field) ...] exp1 exp2 ...) clause ...)
       (with-syntax
         ([predicate (mk-name (syntax name) (syntax name) '?)]
          [(reader ...) (map (lambda (fld)
                               (mk-name (syntax name) (syntax name) "->" fld))
                             (syntax (field ...)))])
         (syntax (if (predicate var)
                     (let ([fname (reader var)] ...) exp1 exp2 ...)
                     (_ var clause ...))))]
      [(_ var (name (field ...) exp1 exp2 ...) clause ...)
       (syntax (_ var (name ([field field] ...) exp1 exp2 ...) clause ...))])))
@

Finally, [[let-values*]]:
<<File [[common.ss]]>>=
(define-syntax let-values*
  (lambda (x)
    (syntax-case x ()
      [(_ () e ...) (syntax (let () e ...))]
      [(_ ([(n ...) i ...]) e ...) (syntax (call-with-values
                                             (lambda () (let () i ...))
                                             (lambda (n ...) (let () e ...))))]
      [(_ (b0 b1 ...) e ...) (syntax (_ (b0) (_ (b1 ...) e ...)))])))
@

\section{CODE CHUNKS}
\nowebchunks

\end{document}
