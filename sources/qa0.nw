\documentclass[twoside]{article}
\usepackage{noweb}
\noweboptions{externalindex,longchunks,longxref}
\usepackage{color}
\definecolor{darkblue}{cmyk}{1,1,0,0.7}
\usepackage[dvipdfm,colorlinks=true,linkcolor=darkblue]{hyperref}
\newcommand{\note}[1]{$[\![$NB: #1$]\!]$}
\setlength{\parindent}{0pt}
\setlength{\topmargin}{-40pt}
\setlength{\oddsidemargin}{-16pt}
\setlength{\evensidemargin}{-16pt}
\setlength{\textwidth}{522pt}
\setlength{\textheight}{680pt}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\title{QA---Register Transfer Language}
\author{Andrew Pochinsky}
\catcode`\$=11
\date{$Id$}
\catcode`\$=3

\newcommand{\any}{${}^{*}$}
\newcommand{\oneplus}{${}^{+}$}
\newcommand{\nonterminal}[1]{$\langle$\emph{#1}$\rangle$}
\newcommand{\is}{&$\rightarrow$&&}
\newcommand{\also}{&&$|$&}
\newcommand{\terminal}[1]{\texttt{#1}}
\newcommand{\nothing}{\terminal{/* nothing */}}
\newenvironment{grammar}{\par\medskip\begin{tabular}{lccl}}{%
\end{tabular}\medskip\par}

\begin{document}
\maketitle
\section{GRAMMAR}
Here we define the grammar for QA. We start with the file level constructs:

\begin{grammar}
\nonterminal{qa0} \is \nonterminal{decl}\any\\
\nonterminal{decl}\is\nonterminal{alias}\\
  \also\nonterminal{constant}\\
  \also\nonterminal{structure}\\
  \also\nonterminal{array}\\
  \also\nonterminal{top level macro}\\
\nonterminal{top level macro}\is\nonterminal{procedure}\\
  \also\terminal{(} \terminal{repeat}
         \terminal{(} \nonterminal{iterator}\any \terminal{)}
         \nonterminal{top level macro}\oneplus \terminal{)}\\
\end{grammar}

There are two kinds of iterators. One is an enumeration, another is loop-like
\begin{grammar}
\nonterminal{iterator}\is\terminal{(}
   \nonterminal{name} \terminal( \nonterminal{a-value}\oneplus \terminal)
     \terminal{)}\\
  \also\terminal{(}
   \nonterminal{name} \nonterminal{inclusive constant low}
      \nonterminal{exclusive constant high} \terminal{)}\\
\nonterminal{inclusive constant low}\is\nonterminal{constant expr}\\
\nonterminal{exclusive constant high}\is\nonterminal{constant expr}\\
\end{grammar}

Integer constants may be defined and given names. We do not specify the
allowed set of operations in \nonterminal{c-expr} here,
they will be introduced as needed.

\begin{grammar}
\nonterminal{constant}\is\terminal{(} \terminal{constant}
 \nonterminal{name} \nonterminal{constant expression}\terminal{)}\\
\nonterminal{constant expression}\is\terminal{(} \terminal{const}
  \nonterminal{c-expr} \terminal{)}\\
\nonterminal{c-expr}\is\nonterminal{number}\\
  \also\nonterminal{name}\\
  \also\nonterminal{string}\\
  \also\terminal{(} \nonterminal{c-op} \nonterminal{c-expr}\any\terminal{)}\\
\nonterminal{c-op}\is\nonterminal{symbol}\\
\nonterminal{name}\is\nonterminal{symbol}\\
\end{grammar}

Structure definitions provide a way to compute offsets to various elements
within a memory block. They also contain enough information to generate a
corresponding C declaration.

\begin{grammar}
\nonterminal{structure}\is\terminal{(} \terminal{structure}
 \nonterminal{external name}
   \terminal{(}\nonterminal{field}\oneplus\terminal{)}\terminal{)}\\
\nonterminal{field}\is\terminal{(} \nonterminal{external name}
  \nonterminal{type name} \terminal{)}\\
\nonterminal{external name}\is\nonterminal{name} \nonterminal{string}\\
\nonterminal{type name}\is\nonterminal{name}\\
\end{grammar}

Each \nonterminal{structure} definition provides the following set of
\nonterminal{c-expr}. First, there is \terminal{(size-of}
\nonterminal{structure name}\terminal{)} which computes the size
of the structure in bytes. It properly handles all alignment requirements for
parts of the structure and produces the same result as
\verb|sizeof (struct foo)| in C where \verb|foo| is the corresponding C tag.
Second, there is \terminal{(align-of} \nonterminal{structure name}\terminal{)}
computing the alignment of the structure in bytes. It is always a power of 2.
In addition, for each component of the structure, there is 
\terminal{(offset-of} \nonterminal{structure name}
\nonterminal{field name}\terminal{)}, which computes an offset from the
begining of the structure to the given field.

Array types are introduced with the following contruct:
\begin{grammar}
\nonterminal{array}\is\terminal{(} \terminal{array}
 \nonterminal{external name} \nonterminal{base type name}
     \nonterminal{constant expression}\terminal{)}\\
\nonterminal{base type name}\is\nonterminal{type name}
\end{grammar}

There is also a set of predefined types. At this stage we do not specify
them.

Constants, predefined types, arrays, and structures may be aliased. For
simplicity, we do not keep separate name spaces for them. All definitions are
checked for conflicts.
\begin{grammar}
\nonterminal{alias}\is\terminal{(} \terminal{alias}
 \nonterminal{new name} \nonterminal{old name}\terminal{)}\\
\nonterminal{new name}\is\nonterminal{name}\\
\nonterminal{old name}\is\nonterminal{name}\\
\end{grammar}

The last part of the top level structure is procedure. At this time we only
define leaf procedures. Since we need to generate multiple variants of the
procedures from the same sources, external names are generated from the
attributes. The internal names are not used in this version.

\begin{grammar}
\nonterminal{procedure}\is\terminal{(} \terminal{procedure}
  \nonterminal{name} \terminal{(} \nonterminal{attribute}\any \terminal{)}
  \terminal{(} \nonterminal{argument}\any \terminal{)}
  \nonterminal{code}\oneplus \terminal{)}\\
\nonterminal{argument}\is\terminal{(}
    \nonterminal{argument name} \nonterminal{type name}
    \nonterminal{C type} \nonterminal{C name} \terminal{)}\\
\nonterminal{argument name}\is\nonterminal{name}\\
\nonterminal{C type}\is\nonterminal{string}\\
\nonterminal{C name}\is\nonterminal{string}\\
\nonterminal{attribute}\is\nonterminal{name}\\
  \also\terminal{(} \nonterminal{name}
                  \nonterminal{a-value}\oneplus \terminal{)}\\
\nonterminal{a-value}\is\nonterminal{string}\\
   \also\nonterminal{number}\\
   \also\nonterminal{symbol}\\
\end{grammar}

The code is design to help with instruction generation and data flow analysis.
At this stage we keep regular loops and provide conditional branching. There is
no back branches or returns. We do not provide automatic variables since
there are only leaf procedures.

\begin{grammar}
\nonterminal{code}\is \nonterminal{operation}\\
  \also\nonterminal{memory access}\\
  \also\nonterminal{block}\\
  \also\nonterminal{loop}\\
  \also\nonterminal{conditional}\\
  \also\nonterminal{inner macro}\\
\nonterminal{inner macro}\is\terminal{(} \terminal{repeat}
         \terminal{(} \nonterminal{iterator}\any \terminal{)}
         \nonterminal{code}\oneplus \terminal{)}\\
\end{grammar}

Operations modify only their outputs and depends only on their inputs. The
name space of the opcodes is open-ended, the attributes are specific for each
opcode.

\begin{grammar}
\nonterminal{operation}\is\terminal{(} \terminal{op}
  \nonterminal{opcode} \terminal{(} \nonterminal{attribute}\any \terminal{)}
  \terminal{(} \nonterminal{output}\oneplus \terminal{)}
  \terminal{(} \nonterminal{input}\any \terminal{)} \terminal{)}\\
\nonterminal{opcode}\is\nonterminal{name}\\
\nonterminal{output}\is\nonterminal{name}\\
\nonterminal{input}\is\nonterminal{register}\\
    \also \nonterminal{constant expression}\\
\nonterminal{register}\is\terminal{(} \terminal{reg}
    \nonterminal{name} \terminal{)}
\end{grammar}

Memory operations read and write memory. The type of the data is provided
explicitly and is checked for writes (reads define the output which is checked
at use.)

\begin{grammar}
\nonterminal{memory access}\is
  \terminal{(} \terminal{load} \nonterminal{type name}
              \terminal{(} \nonterminal{attribute}\any \terminal{)}
          \nonterminal{output}
          \nonterminal{address} \terminal{)}\\
 \also
  \terminal{(} \terminal{store} \nonterminal{type name}
              \terminal{(} \nonterminal{attribute}\any \terminal{)}
          \nonterminal{address}
          \nonterminal{input} \terminal{)}\\
\nonterminal{address}\is\terminal{(} \nonterminal{input}\oneplus \terminal{)}\\
\end{grammar}

The next is the block. It packages codes together into a single code to
simplify syntax.

\begin{grammar}
\nonterminal{block}\is\terminal{(} \terminal{begin}
  \nonterminal{code}\oneplus \terminal{)}\\
\end{grammar}

The conditional is also simple. We provide two forms. The constant predicates
are handled in the compile time.
\begin{grammar}
\nonterminal{conditional}\is\terminal{(} \terminal{if-else}
  \nonterminal{predicate} \nonterminal{non-zero branch}
                          \nonterminal{zero branch} \terminal{)}\\
 \also \terminal{(} \terminal{if}
  \nonterminal{predicate} \nonterminal{non-zero branch} \terminal{)}\\
\nonterminal{predicate}\is\nonterminal{input}\\
\nonterminal{non-zero branch}\is\nonterminal{code}\\
\nonterminal{zero branch}\is\nonterminal{code}\\
\end{grammar}

The loop construct always runs through a given number of iterations. The
limits are computed once at the beginning of the loop. The loop variable is
of time int and is visible only inside the loop. Unrolling and prefetching
inside the loop is controlled by the attributes. The loop step is alway $1$.

\begin{grammar}
\nonterminal{loop}\is\terminal{(} \terminal{loop}
  \terminal{(} \nonterminal{attribute}\any \terminal{)}
  \terminal{(} \nonterminal{loop variable} \nonterminal{inclusive low}
              \nonterminal{exclusive high} \terminal{)}
  \nonterminal{code}\oneplus \terminal{)}\\
\nonterminal{loop variable}\is\nonterminal{output}\\
\nonterminal{inclusive low}\is\nonterminal{input}\\
\nonterminal{exclusive high}\is\nonterminal{input}\\
\end{grammar}

It is possible to use quare brackets [[[]]] instead if parentheses [[()]] in
any place as long as the closing backet matches the open one.
Also, [[;]] starts a commnet upto the end of line.

\section{PARSING}
Function [[parse-qa0]] converts the surface syntax into an abstract syntax tree.
Checks are done at this stage, but since we use Scheme's [[read]], error
reporting does not include line numbers.

<<File [[parser.ss]]>>=
<<Abstract syntax tree definitions>>
(define (parse-qa0-file file-name)
  <<Parser helpers>>
  (let ([f (open-input-file file-name)])
    (let loop ([s-expr (read f)] [ast (empty-ast)])
      (cond
        [(eof-object? s-expr) ast]
        [else (loop (read f) (parse-top s-expr ast))]))))
@

\subsection{AST definitions}
Definitions of the abstract syntax tree mirror the grammar.
<<Abstract syntax tree definitions>>=
(define-variant qa0-top (decl*))
(define-variant qa0-alias (old-name new-name))
(define-variant qa0-const (name value))
(define-variant qa0-struct (name c-name
                            field-name*
                            field-type*
                            field-c-name*))
(define-variant qa0-array (name c-name base-name size))
(define-variant qa0-proc (attr*
                          name
                          arg-name*
                          arg-type*
                          arg-c-name*
                          arg-c-type*
                          code*))
(define-variant qa0-repeat-list (id value* body*))
(define-variant qa0-repeat-range (id low high body*))
@

Here are codes:
<<Abstract syntax tree definitions>>=
(define-variant qa0-operation (attr* name output* input*))
(define-variant qa0-load (attr* type output addr*))
(define-variant qa0-store (attr* type addr* value))
(define-variant qa0-loop (attr* var low high code*))
(define-variant qa0-if (var true-code* false-code*))
(define-variant qa0-macro-list (id value* code*))
(define-variant qa0-macro-range (id low high code*))
@

The attributes:
<<Abstract syntax tree definitions>>=
(define-variant qa0-attr (name value*))
@

Constant expressions and registers:
<<Abstract syntax tree definitions>>=
(define-variant c-expr-id (id))
(define-variant c-expr-quote (literal))
(define-variant c-expr-number (number))
(define-variant c-expr-string (string))
(define-variant c-expr-op (name c-expr*))
(define-variant reg (name))
@

\subsection{Parser helpers}
In many places a list is expected. Here we check that a list is
provided indeed.
<<Parser helpers>>=
(define (check-list msg in cmp min-size)
  (if (not (list? in))
      (error 'parse-qa0 "List expected in ~a, found~%  ~a~%"
             msg in))
  (if (not (cmp (length in) min-size))
      (error 'parse-qa0
             "List of ~a ~a is expected in ~a, found:~%   ~a~%"
             (if (eq? cmp =) "exactly" "at least")
             min-size msg in)))
@
We also often check if something is a name:
<<Parser helpers>>=
(define (check-name msg form name)
  (if (not (symbol? name))
      (error 'parse-qa0
             "Expecting name for ~a, found ~a in:~%~a~%"
             msg name form)))
@
and that something is a string:
<<Parser helpers>>=
(define (check-string msg form string)
  (if (not (string? string))
      (error 'parse-qa0
             "Expecting string for ~a, found ~a in:~%~a~%"
             msg string form)))
@

Checking the syntax of the attribute
<<Parser helpers>>=
(define (check-attrib* msg form attr*)
  (for-each (lambda (attr) (check-attrib msg form attr)) attr*))
(define (check-attrib msg form attr)
  (if (not (or (symbol? attr)
               (and (list? attr)
                    (>= (length attr) 1)
                    (symbol? (car attr)))))
      (error 'parse-qa0 "Expecting attribute for ~a, found ~a in~%~a~%"
             msg attr form)))
@

Each output is a symbol:
<<Parser helpers>>=
(define (check-output* msg form out*)
  (cond
    [(null? out*) #t]
    [(not (symbol? (car out*)))
       (error 'parse-qa0 "Bad value for output of ~a, found ~a in~%~a~%"
               msg (car out*) form)]
    [else (check-output* msg form (cdr out*))]))
@

Each input is either a constant or a register:
<<Parser helpers>>=
(define (check-input* msg form in*)
  (for-each (lambda (in) (check-input msg form in)) in*))
(define (check-input msg form in)
  (check-list msg in = 2)
  (if (case (car in)
        [(reg) (not (symbol? (cadr in)))]
        [(const) #f]
        [else #t])
      (error 'parse-qa0 "Bad value for input of ~a, found ~a in ~%~a~%"
             msg in form)))
@
There are two iterator forms:
<<Parser helpers>>=
(define (check-iterator msg form iter)
   (check-list msg iter >= 2)
   (check-name msg form (car iter))
   (case (length iter)
     [(2) (check-list "iterator range" (cadr iter) >= 0)]
     [(3) #t]
     [else (error 'parse-qa0 "Bad iterator form of ~a, found ~a in~%~a~%"
                  msg iter form)]))
@

We start with an empty AST. It is a valid input, by the way:
<<Parser helpers>>=
(define (empty-ast) (make-qa0-top '()))
@

Add another top-level form:
<<Parser helpers>>=
(define (parse-top s-expr ast)
   (check-list "top level" s-expr >= 1)
   (variant-case ast
     [qa0-top (decl*)
       (case (car s-expr)
         <<Recognize top-level forms>>
         [else (error 'parse-qa0 "Unknown form:~%~a~%" s-expr)])]))
@

<<Recognize top-level forms>>=
[(alias) (make-qa0-top (append decl* (list (parse-alias s-expr))))]
@
<<Parser helpers>>=
(define (parse-alias s-expr)
  (check-list "top level alias" s-expr = 3)
  (check-name "alias new name" s-expr (cadr s-expr))
  (check-name "alias old name" s-expr (caddr s-expr))
  (make-qa0-alias (caddr s-expr) (cadr s-expr)))
@

<<Recognize top-level forms>>=
[(constant) (make-qa0-top (append decl* (list (parse-constant s-expr))))]
@
<<Parser helpers>>=
(define (parse-constant s-expr)
  (check-list "constant" s-expr = 3)
  (check-name "constant name" s-expr (cadr s-expr))
  (make-qa0-const (cadr s-expr) (parse-const-expr (caddr s-expr))))
@

<<Recognize top-level forms>>=
[(array) (make-qa0-top (append decl* (list (parse-array s-expr))))]
@
<<Parser helpers>>=
(define (parse-array s-expr)
  (check-list "array" s-expr = 5)
  (check-name "array name" s-expr (cadr s-expr))
  (check-string "array c-name" s-expr (caddr s-expr))
  (check-name "array base name" s-expr (cadddr s-expr))
  (make-qa0-array (cadr s-expr) (caddr s-expr) (cadddr s-expr)
                  (parse-const-expr (car (cddddr s-expr)))))
@

<<Recognize top-level forms>>=
[(structure) (make-qa0-top (append decl* (list (parse-structure s-expr))))]
@
<<Parser helpers>>=
(define (parse-structure s-expr)
  (check-list "structure" s-expr = 4)
  (let ([name (cadr s-expr)]
        [c-name (caddr s-expr)]
        [f* (cadddr s-expr)])
    (check-name "struct name" s-expr name)
    (check-string "struct c-name" s-expr c-name)
    (map (lambda (f)
            (check-list "struct field" f = 3)
            (check-name "struct field name" s-expr (car f))
            (check-string "struct field c-name" s-expr (cadr f))
            (check-name "struct field type" s-expr (caddr f)))
         f*)
    (make-qa0-struct name c-name (map car f*) (map caddr f*) (map cadr f*))))
@

<<Recognize top-level forms>>=
[(repeat procedure) (make-qa0-top (append decl* (parse-repeat s-expr)))]
@
<<Parser helpers>>=
(define (parse-repeat s-expr)
  (check-list "top level repeat" s-expr >= 1)
  (case (car s-expr)
    [(repeat)
       (check-list "top level repeat" s-expr >= 3)
       (let loop ([bind* (cadr s-expr)])
         (cond
           [(null? bind*) (let do-body ([p* '()] [b* (cddr s-expr)])
                            (cond
                              [(null? b*) p*]
                              [else (do-body (append p* (parse-repeat (car b*)))
                                             (cdr b*))]))]
           [else (check-iterator "top level repeat" s-expr (car bind*))
             (list
               (case (length (car bind*))
                 [(2) (make-qa0-repeat-list (caar bind*)
                                            (map parse-a-value (cadar bind*))
                                            (loop (cdr bind*)))]
                 [(3) (make-qa0-repeat-range (caar bind*)
                                             (parse-const-expr (cadar bind*))
                                             (parse-const-expr (caddar bind*))
                                             (loop (cdr bind*)))]
                 [else (error 'qa0 "Internal error in parse-repeat")]))]))]
    [(procedure) (list (parse-procedure s-expr))]
    [else (error 'qa0 "Bad form at top level~%~a~%" s-expr)]))
@

Parsing an a-value is trivial:
<<Parser helpers>>=
(define (parse-a-value expr)
   (if (or (number? expr)
           (symbol? expr)
           (string? expr)) expr
       (error 'parse-qa0 "a-value is not ~a~%" expr)))
@

<<Parser helpers>>=
(define (parse-procedure s-expr)
   (check-list "procedure" s-expr >= 5)
   (check-name "procedure name" s-expr (cadr s-expr))
   (check-attrib* "procedure attributes" s-expr (caddr s-expr))
   (check-list "procedure arguments" (cadddr s-expr) >= 0)
   (map (lambda (arg)
          (check-list "procedure argument" arg = 4)
          (check-name "argument name" arg (car arg))
          (check-name "argument type" arg (cadr arg))
          (check-string "argument c-name" arg (caddr arg))
          (check-string "argument c-type" arg (cadddr arg)))
        (cadddr s-expr))
   (parse-code* (cddddr s-expr)
                (lambda (code*)
                  (make-qa0-proc (map parse-attr (caddr s-expr))
                                 (cadr s-expr)
                                 (map user-reg (map car (cadddr s-expr)))
                                 (map cadr (cadddr s-expr))
                                 (map caddr (cadddr s-expr))
                                 (map cadddr (cadddr s-expr))
                                 code*))))
@
Parse a list of codes flattening blocks.
<<Parser helpers>>=
(define (parse-code* code* k)
   (if (null? code*) (k '())
       (parse-code* (cdr code*)
         (lambda (op*)
           (let ([code (car code*)])
             (check-list "operation" code >= 1)
             (case (car code)
               [(begin) (parse-code* (cdr code)
                                     (lambda (op2*) (k (append op2* op*))))]
               [(macro) (k (parse-macro code op*))]
               [else (k (cons (parse-code code) op*))]))))))
@

Attribute may be without values or it can contain a list of a-values:
<<Parser helpers>>=
(define (parse-attr f)
   (cond
    [(symbol? f) (make-qa0-attr f '())]
    [else (check-list "attribute" f >= 1)
       (make-qa0-attr (car f) (map parse-a-value (cdr f)))]))
@

Parsing a code element dispatches on the [[car]]:
<<Parser helpers>>=
(define (parse-code f)
  (check-list "code" f >= 1)
  (case (car f)
    <<Recognize code forms>>
    [else (error 'parse-qa0 "Unexpected code~%~a~%" f)]))
@

Let us start with an [[op]]:
<<Recognize code forms>>=
[(op) (parse-op f)]
@
<<Parser helpers>>=
(define (parse-op f)
  (check-list "code op" f = 5)
  (let ([name (cadr f)]
        [attr* (caddr f)]
        [out* (cadddr f)]
        [in* (car (cddddr f))])
    (check-name "code op name" f name)
    (check-attrib* "code op attirbutes" f attr*)
    (check-output* "code op outputs" f out*)
    (check-input* "code op inputs" f in*)
    (make-qa0-operation (map parse-attr attr*)
                        name
                        (map parse-output out*)
                        (map parse-input in*))))
@
<<Parser helpers>>=
(define (parse-output out) (parse-reg out))
@
<<Parser helpers>>=
(define (parse-input in)
  (case (car in)
    [(reg) (parse-reg (cadr in))]
    [(const) (parse-const-expr in)]
    [else (error 'parse-qa0 "Internal error in parse-input")]))
@

All input registers are prefixed with [[_]]. Other prefixed will be used for
generated registers.
<<Parser helpers>>=
(define (parse-reg name) (make-reg (user-reg name)))
(define (user-reg name) (string->symbol (format "_~a" name)))
@

<<Recognize code forms>>=
[(load) (parse-load f)]
@
<<Parser helpers>>=
(define (parse-load f)
  (check-list "load" f = 5)
  (let ([type (cadr f)]
        [attr* (caddr f)]
        [out (cadddr f)]
        [addr (car (cddddr f))])
    (check-attrib* "load" f attr*)
    (check-name "load" f type)
    (check-output* "load" f (list out))
    (check-input* "load" f addr)
    (make-qa0-load (map parse-attr attr*)
                   type
                   (parse-output out)
                   (map parse-input addr))))
@

<<Recognize code forms>>=
[(store) (parse-store f)]
@
<<Parser helpers>>=
(define (parse-store f)
  (check-list "store" f = 5)
  (let ([type (cadr f)]
        [attr* (caddr f)]
        [addr (cadddr f)]
        [value (car (cddddr f))])
    (check-attrib* "store" f attr*)
    (check-name "store" f type)
    (check-input* "store" f addr)
    (check-input "store" f value)
    (make-qa0-store (map parse-attr attr*)
                    type
                    (map parse-input addr)
                    (parse-input value))))
@

<<Recognize code forms>>=
[(loop) (parse-loop f)]
@
<<Parser helpers>>=
(define (parse-loop f)
  (check-list "loop" f >= 4)
  (let ([attr* (cadr f)]
        [ctl (caddr f)]
        [code* (cdddr f)])
    (check-attrib* "loop" f attr*)
    (check-list "loop control" ctl = 3)
    (parse-code* code*
      (lambda (op*)
        (make-qa0-loop (map parse-attr attr*)
                       (parse-output (car ctl))
                       (parse-input (cadr ctl))
                       (parse-input (caddr ctl))
                       op*)))))
@

<<Recognize code forms>>=
[(if) (parse-if f)]
@
<<Parser helpers>>=
(define (parse-if f)
  (check-list "if" f = 3)
  (let ([c (cadr f)]
        [t (caddr f)])
    (check-input "if predicate" f c)
    (check-list "if branch" t >= 1)
    (make-qa0-if (parse-input c) (parse-seq t) '())))
@

<<Recognize code forms>>=
[(if-else) (parse-if-else f)]
@
<<Parser helpers>>=
(define (parse-if-else form)
  (check-list "if-else" form = 4)
  (let ([c (cadr form)]
        [t (caddr form)]
        [f (cadddr form)])
    (check-input "if-else predicate" form c)
    (check-list "if-else true branch" t >= 1)
    (check-list "if-else false branch" f >= 1)
    (make-qa0-if (parse-input c) (parse-seq t) (parse-seq f))))
@

<<Parser helpers>>=
(define (parse-seq s)
  (if (and (list s) (> (length s) 0) (equal? (car s) 'begin))
      (parse-code* (cdr s) (lambda (p*) p*))
      (list (parse-code s))))
@

<<Parser helpers>>=
(define (parse-macro form op*)
  (check-list "macro" form >= 3)
  (let ([iterator* (cadr form)]
        [code* (cddr form)])
    (let loop ([i* iterator*] [t* op*])
      (cond
        [(null? i*) (parse-code* code* (lambda (c*) (append c* t*)))]
        [else (let ([i (car i*)] [i* (cdr i*)])
                (check-iterator "macro" form i)
                (case (length i)
                  [(2) (let ([c* (loop i* '())]
                             [v* (map parse-a-value (cadr i))]
                             [id (car i)])
                         (cons (make-qa0-macro-list id v* c*) t*))]
                  [(3) (let ([c* (loop i* '())]
                             [id (car i)]
                             [lo (parse-const-expr (cadr i))]
			     [hi (parse-const-expr (caddr i))])
                         (cons (make-qa0-macro-range id lo hi c*) t*))]
                  [else (error 'qa0 "Internal error in parse-macro")]))]))))
@

Finally, the constant expressions:
<<Parser helpers>>=
(define (parse-const-expr form)
  (check-list "constant expression" form = 2)
  (parse-c-expr (cadr form)))
(define (parse-c-expr form)
  (cond
    [(number? form) (make-c-expr-number form)]
    [(symbol? form) (make-c-expr-id form)]
    [(string? form) (make-c-expr-string form)]
    [(and (= (length form) 2) (eq? (car form) 'quote))
      (make-c-expr-quote (cadr form))]
    [(and (list? form) (>= (length form) 1) (symbol? (car form)))
      (make-c-expr-op (car form) (map parse-c-expr (cdr form)))]
    [else (error 'parse-qa0 "constant expression is bad:~%~a~%" form)]))
@

We also need a procedure to build a procedure name:
<<File [[parser.ss]]>>=
(define (build-proc-name stem* env)
  (let loop ([r (ce-lookup env 'proc-prefix "missing proc-prefix in CE")]
             [stem* stem*])
    (cond
      [(null? stem*) (format "~a~a" r
                             (ce-lookup env 'proc-suffix
                                        "missing proc-suffix in CE"))]
      [else (loop (format "~a~a" r (car stem*)) (cdr stem*))])))
@

\section{CONSTANT FOLDING}
This pass computes all constant expressions and expands the macros. Constant
conditional are also handled at this stage as well as other constant operations.
File [[cfolding.ss]] should be loaded after [[parser.ss]]. It defines
one function, [[fold-constants]] that convers [[qa0-top]] into [[qa0-top]]. The
returned value has constants only of the form [[(const N)]] where [[N]] is a
number.
<<File [[cfolding.ss]]>>=
<<Folding environment routines>>
(define (fold-constants/env ast machine real)
  <<Folding helpers>>
  (variant-case ast
    [qa0-top (decl*)
       (let loop ([in* decl*] [out* '()] [env (ce-start-env machine real)])
         (cond
           [(null? in*) (values (make-qa0-top (reverse out*)) env)]
           [else (let-values* ([(out* env) (cf-decl (car in*) out* env)])
                   (loop (cdr in*) out* env))]))]))
(define (fold-constants ast machine real)
  (let-values* ([(ast env) (fold-constants/env ast machine real)])
    ast))
@
The [[machine]] is a procedure that adds definitions of [[int]], [[double]],
[[float]], [[pointer]], [[verctor-float]], and [[vector-double]] to the
environment passed as an argument. It returns a new environment.
<<Folding helpers>>=
(define (ce-start-env machine real)
  (let* ([env (ce-empty-env)]
         [env (machine env)]
         [env (ce-bind env 'proc-prefix "mdwf_")]
         [env
           (case real
             [(double) (let* ([env (ce-bind env 'proc-suffix "_D")]
                              [env (ce-add-alias env 'REAL    'double)]
                              [env (ce-add-alias env 'COMPLEX 'complex-double)]
                              [env (ce-add-alias env 'VECTOR  'vector-double)])
                         env)]
             [(float) (let* ([env (ce-bind env 'proc-suffix "_F")]
                             [env (ce-add-alias env 'REAL    'float)]
                             [env (ce-add-alias env 'COMPLEX 'complex-float)]
                             [env (ce-add-alias env 'VECTOR  'vector-float)])
                        env)]
             [else (error 'fold-constant "Bad value of REAL: ~a" real)])]
         [env (ce-add-const env '*mdwf-start-sum-dimension*
                                 mdwf-start-sum-dimension)]
         [env (ce-add-const env '*mdwf-start-sum-direction*
                                mdwf-start-sum-direction)])
     (let loop ([env env] [p* mdwf-basis])
       (cond
         [(null? p*) env]
         [else (loop (ce-bind env (caar p*) (cdar p*)) (cdr p*))]))))
@
<<Folding environment routines>>=
(define (ce-empty-env) '())
@

We rebuild the AST while walking though it.
<<Folding helpers>>=
(define (cf-decl ast out* env)
  (variant-case ast
    [qa0-alias (old-name new-name) (cf-alias old-name new-name out* env)]
    [qa0-const (name value) (cf-const name value out* env)]
    [qa0-struct (name c-name field-name* field-type* field-c-name*)
        (cf-struct name c-name field-name* field-type* field-c-name* out* env)]
    [qa0-array (name c-name base-name size)
        (cf-array name c-name base-name size out* env)]
    [qa0-proc (attr* name arg-name* arg-type* arg-c-name* arg-c-type* code*)
       (cf-proc attr* name arg-name* arg-type* arg-c-name* arg-c-type*
                code* out* env)]
    [qa0-repeat-list (id value* body*)
       (cf-repeat-list id value* body* out* env)]
    [qa0-repeat-range (id low high body*)
       (cf-repeat-range id low high body* out* env)]))
@

Aliases are removed after updating the environment.
<<Folding helpers>>=
(define (cf-alias old new out* env)
  (values out* (ce-add-alias env new old)))
@

Constants are also removed at this stage.
<<Folding helpers>>=
(define (cf-const name value out* env)
  (let ([v (cf-eval-const value env)])
    (values out* (ce-add-const env name v))))
@

We keep structures and arrays as they are needed to produce a header file.
<<Folding helpers>>=
(define (cf-struct name c-name field-name* field-type* field-c-name* out* env)
  (values (cons (make-qa0-struct name c-name
                                 field-name* field-type* field-c-name*)
                out*)
          (ce-add-struct env name c-name field-name* field-type*)))
@
<<Folding helpers>>=
(define (cf-array name c-name base size out* env)
  (let ([size (cf-eval-const size env)])
    (values (cons (make-qa0-array name c-name base (cf-rewrap size)) out*)
            (ce-add-array env name c-name base size))))
@
In procedures we fold instructions. Care should be taken of loops and
conditionals, as they may expand into a sequence of instructions.
<<Folding helpers>>=
(define (cf-proc attr* name arg-name* arg-type* arg-c-name* arg-c-type*
                 code* out* env)
  (values (cons (make-qa0-proc (cf-attr* attr* env)
                               name
                               arg-name*
                               arg-type*
                               arg-c-name*
                               arg-c-type*
                               (cf-block code* env))
                out*)
          env))
@

List repeats do not evaluate literals.
<<Folding helpers>>=
(define (cf-repeat-list id value* body* out* env)
  (let loop-values ([value* value*] [out* out*])
    (cond
      [(null? value*) (values out* env)]
      [else (let ([env-x (ce-add-const env id (car value*))])
              (let loop-body ([body* body*] [out* out*])
                (cond
                  [(null? body*) (loop-values (cdr value*) out*)]
                  [else (loop-body (cdr body*)
                                   (cf-repeat (car body*) out* env-x))])))])))
@
On the other hand, a range repeat evaluates both ranges:
<<Folding helpers>>=
(define (cf-repeat-range id low high body* out* env)
  (let ([low (cf-eval-const low env)]
        [high (cf-eval-const high env)])
    (let loop-values ([i low] [out* out*])
      (cond
       [(>= i high) (values out* env)]
       [else (let ([env-x (ce-add-const env id i)])
               (let loop-body ([body* body*] [out* out*])
                 (cond
                   [(null? body*) (loop-values (+ i 1) out*)]
                   [else (loop-body (cdr body*)
                                    (cf-repeat (car body*) out* env-x))])))]))))
@

<<Folding helpers>>=
(define (cf-repeat ast out* env)
   (let-values* ([(out* env)
       (variant-case ast
         [qa0-proc (attr* name arg-name* arg-type* arg-c-name* arg-c-type*
                    code*)
            (cf-proc attr* name arg-name* arg-type* arg-c-name* arg-c-type*
                     code* out* env)]
         [qa0-repeat-list (id value* body*)
            (cf-repeat-list id value* body* out* env)]
         [qa0-repeat-range (id low high body*)
            (cf-repeat-range id low high body* out* env)])])
      out*))
@

For the attributes the values are weakly substituted with literals.
<<Folding helpers>>=
(define (cf-attr attr env)
  (variant-case attr
    [qa0-attr (name value*)
      (make-qa0-attr name
                          (map (lambda (v) (cf-eval-literal v env)) value*))]))
(define (cf-attr* attr* env)
  (map (lambda (attr) (cf-attr attr env)) attr*))
@

Finally, the code.
<<Folding helpers>>=
(define (cf-block code* env)
  (let loop ([code* code*] [out* '()])
    (cond
      [(null? code*) (reverse out*)]
      [else (loop (cdr code*) (cf-code (car code*) out* env))])))
@

<<Folding helpers>>=
(define (cf-code* code* out* env)
  (let loop ([code* code*] [out* out*])
    (cond
      [(null? code*) out*]
      [else (loop (cdr code*) (cf-code (car code*) out* env))])))
@

<<Folding helpers>>=
(define (cf-code code out* env)
  (variant-case code
    [qa0-operation (attr* name output* input*)
       (cf-operation attr* name output* input* out* env)]
    [qa0-load (attr* type output addr*)
       (cf-load attr* type output addr* out* env)]
    [qa0-store (attr* type addr* value)
       (cf-store attr* type addr* value out* env)]
    [qa0-loop (attr* var low high code*)
       (cf-loop attr* var low high code* out* env)]
    [qa0-if (var true-code* false-code*)
       (cf-if var true-code* false-code* out* env)]
    [qa0-macro-list (id value* code*)
       (cf-macro-list id value* code* out* env)]
    [qa0-macro-range (id low high code*)
       (cf-macro-range id low high code* out* env)]))
@
In the conditional we first evaluate the control expression and if it is a
constant, eliminate the unreacheable code.
<<Folding helpers>>=
(define (cf-if var true* false* out* env)
  (let ([var (cf-input var env)])
    (variant-case var
      [c-expr-number (number) (if (zero? number) (cf-code* false* out* env)
                                                 (cf-code* true* out* env))]
      [reg (name) (cons (make-qa0-if var (cf-block true* env)
                                     (cf-block false* env))
                        out*)])))
@

In [[operation]], we evaluate attributes and inputs. We may extend constant
folding later to [[name]] and [[output*]].
<<Folding helpers>>=
(define (cf-operation attr* name output* input* out* env)
  (cons (make-qa0-operation (cf-attr* attr* env)
                            name
                            output*
                            (cf-input* input* env))
        out*))
@
Memory accesses are similar:
<<Folding helpers>>=
(define (cf-load attr* type output addr* out* env)
  (cons (make-qa0-load (cf-attr* attr* env)
                       type
                       output
                       (cf-addr* addr* env))
        out*))
@

<<Folding helpers>>=
(define (cf-store attr* type addr* value out* env)
  (cons (make-qa0-store (cf-attr* attr* env)
                       type
                       (cf-addr* addr* env)
                       (cf-input value env))
        out*))
@

In [[loop]] only limits and the body are folded. We do not do loop unrolling
here.
<<Folding helpers>>=
(define (cf-loop attr* var low high code* out* env)
   (cons (make-qa0-loop (cf-attr* attr* env)
                        var
                        (cf-input low env)
                        (cf-input high env)
                        (cf-block code* env))
         out*))
@

For [[macros]] the folding is similar to repeats, but we are dealing with
[[code]] inside.
<<Folding helpers>>=
(define (cf-macro-list id value* code* out* env)
  (let loop ([value* value*] [out* out*])
    (cond
      [(null? value*) out*]
      [else (let ([env-x (ce-add-const env id (car value*))])
              (loop (cdr value*) (cf-code* code* out* env-x)))])))
@
<<Folding helpers>>=
(define (cf-macro-range id low high code* out* env)
   (let ([low (cf-eval-const low env)]
         [high (cf-eval-const high env)])
     (let loop ([i low] [out* out*])
       (cond
         [(>= i high) out*]
         [else (loop (+ i 1) (cf-code* code* out*
                                       (ce-add-const env id i)))]))))
@
Addresses are just inputs.
<<Folding helpers>>=
(define (cf-addr* addr* env) (map (lambda (addr) (cf-input addr env)) addr*))
@

Inputs are trivial:
<<Folding helpers>>=
(define (cf-input* input* env) (map (lambda (in) (cf-input in env)) input*))
@

An input is either [[reg]] or [[const]]:
<<Folding helpers>>=
(define (cf-input input env)
  (variant-case input
    [reg () input]
    [else (cf-rewrap (cf-eval-const input env))]))
(define (cf-rewrap c)
    (cond
      [(number? c) (make-c-expr-number c)]
      [(string? c) (make-c-expr-string c)]
      [else (error 'qa0 "Unexpected computed constant is ~a" c)]))
@

Evaluation of constant should find all [[c-expr-id]] with appropriate values.
<<Folding helpers>>=
(define (cf-eval-const const env)
  (variant-case const
    [c-expr-quote (literal) literal]
    [c-expr-op (name c-expr*) (cx-const-op name c-expr* env)]
    [c-expr-string (string) string]
    [c-expr-number (number) number]
    [c-expr-id (id) (ce-lookup env (list 'const id)
                                   "Constant evaluation of ~a" id)]))
@

Literals may stand for themselves, so their evaluation is weaker:
<<Folding helpers>>=
(define (cf-eval-literal literal env)
  (ce-search env (list 'const literal) (lambda (x) x) (lambda () literal)))
@
\subsection{Constant computation}
<<Folding helpers>>=
(define (cx-const-op name expr* env)
  <<Arithmetic helpers>>
  (case name
    [(size-of align-of) (check-id-arg* expr* 1)
                        (let ([type (get-id (car expr*))])
                          (ce-lookup env (list name type)
                                     "Computing (~a ~a)" name type))]
    [(offset-of) (check-id-arg* expr* 2)
                 (let ([type (get-id (car expr*))]
                       [field (get-id (cadr expr*))])
                   (ce-lookup env (list name type field)
                              "Computing (~a ~a ~a)" name type field))]
    [(+) (compute-arith +)]
    [(-) (compute-arith -)]
    [(*) (compute-arith *)]
    [(/) (compute-arith quotient)]
    [(=) (compute-equal)]
    [(shift) (compute-shift)]
    [(and) (compute-and)]
    [(or) (compute-or)]
    [(not) (compute-not)]
    [else (error 'qa0 "Unexpected constant operation ~a" name)]))
@

<<Arithmetic helpers>>=
(define (check-id-arg v)
  (variant-case v
    [c-expr-id () #t]
    [else (error 'qa0 "Expecting id, found ~a" v)]))
(define (check-id-arg* arg* len)
  (if (not (and (list? arg*)
                (= (length arg*) len)))
      (error 'qa0 "Expecting a list of ~a arguments, found ~a" len arg*)
      (let loop ([arg* arg*])
        (cond
          [(null? arg*) #t]
          [else (check-id-arg (car arg*))
                (loop (cdr arg*))]))))
@

<<Arithmetic helpers>>=
(define (get-id v)
  (variant-case v
    [c-expr-id (id) id]))
@

Computation of arithmetic expressions:
<<Arithmetic helpers>>=
(define (compute-arith op)
  (let ([arg* (map (lambda (arg) (cf-eval-const arg env)) expr*)])
    (map check-number-arg arg*)
    (apply op arg*)))
@
<<Arithmetic helpers>>=
(define (check-number-arg arg)
  (if (not (number? arg))
      (error 'qa0 "A number is expected, found ~a" arg)))
@

<<Arithmetic helpers>>=
(define (compute-equal)
  (or (null? expr*)
      (let loop ([v (cf-eval-const (car expr*) env)] [arg* (cdr expr*)])
        (cond
          [(null? arg*) 1]
          [(equal? v (cf-eval-const (car arg*) env)) (loop v (cdr arg*))]
          [else 0]))))
@

<<Arithmetic helpers>>=
(define (compute-shift)
  (cond
    [(not (= (length expr*) 2)) (error 'qa0 "Bad number of args for shift")]
    [else (let ([v (cf-eval-const (car expr*) env)]
                [s (cf-eval-const (cadr expr*) env)])
            (check-number-arg v)
            (check-number-arg s)
            (let loop ([v v] [s s])
              (cond
                [(zero? s) v]
                [(positive? s) (loop (* v 2) (- s 1))]
                [else (loop (quotient v 2) (+ s 1))])))]))
@

<<Arithmetic helpers>>=
(define (compute-not)
  (if (not (= (length expr*) 1)) (error 'qa0 "Bad number of arguments for not"))
  (if (zero? (cf-eval-const (car expr*) env)) 1 0))
@

<<Arithmetic helpers>>=
(define (compute-or)
  (let loop ([arg* expr*])
    (cond
      [(null? arg*) 0]
      [(not (zero? (cf-eval-const (car arg*) env))) 1]
      [else (loop (cdr arg*))])))
@

<<Arithmetic helpers>>=
(define (compute-and)
  (let loop ([arg* expr*])
    (cond
      [(null? arg*) 1]
      [(zero? (cf-eval-const (car arg*) env)) 0]
      [else (loop (cdr arg*))])))
@

\subsection{Constant folding environment manipulation}
Environment search continues in one of its continuation:
<<Folding environment routines>>=
(define (ce-search env key k-found k-missed)
  (let ([x (assoc key env)])
    (if x (k-found (cdr x))
        (k-missed))))
@

The [[ce]] lookup routines either returns the associated value or reports an
error.
<<Folding environment routines>>=
(define (ce-lookup env key msg . args)
  (ce-search env key (lambda (x) x)
             (lambda () (apply error 'qa0 msg args))))
(define (ce-lookup-x env type key msg . args)
  (ce-search env `(,type ,key) (lambda (x) x)
             (lambda () (apply error 'qa0 msg args))))
@

<<Folding environment routines>>=
(define (ce-bind env k v) `((,k . ,v) ,@env))
(define (ce-bind-x env t k v) `(((,t ,k) . ,v) ,@env))
@

<<Folding environment routines>>=
(define (ce-add-const env name value)
  (let* ([t (list 'type name)]
         [x (assoc t env)])
    (cond
      [x (error 'qa0 "Rebinding ~a to ~a is not allowed, old binding ~a"
                      name value (cdr x))]
      [else (let* ([env (ce-bind env t 'const)]
                   [env (ce-bind-x env 'const name value)])
              env)])))
@

<<Folding environment routines>>=
(define (ce-add-type env name c-name size align)
  (let* ([t (list 'type name)]
         [x (assoc t env)])
    (cond
      [x (error 'qa0 "Redefining type ~a is not allowed" name)]
      [else (let* ([env (ce-bind env t 'type)]
                   [env (ce-bind-x env 'size-of name size)]
                   [env (ce-bind-x env 'align-of name align)]
                   [env (ce-bind-x env 'components name '())]
                   [env (ce-bind-x env 'name-of name c-name)])
              env)])))
@
<<Folding environment routines>>=
(define (ce-add-array env name c-name base size)
  (let* ([bs (ce-lookup-x env 'size-of base "Size of array base ~a" base)]
         [ba (ce-lookup-x env 'align-of base
	                "Alignment of array base ~a" base)]
         [t (list 'type name)]
         [x (assoc t env)])
    (cond
      [x (error 'qa0 "Redefining array ~a is not allowed" name)]
      [else (let* ([env (ce-bind env t 'array)]
                   [env (ce-bind-x env 'size-of name (* size bs))]
                   [env (ce-bind-x env 'align-of name ba)]
                   [env (ce-bind-x env 'components name '())]
                   [env (ce-bind-x env 'name-of name c-name)])
              env)])))
@
<<Folding environment routines>>=
(define (ce-add-struct env name c-name field* type*)
   (let* ([t (list 'type name)]
          [x (assoc t env)])
     (cond
       [x (error 'qa0 "Redefining structure ~a is not allowed" name)]
       [else (let loop ([env env] [f* field*] [t* type*]
                        [size 0] [align 1])
               (cond
                 [(null? f*)
                   <<Finish structure construction>>
                   ]
                 [else
                   <<Insert next field and loop>>
                   ]))])))
@
<<Finish structure construction>>=
(let* ([env (ce-bind-x env 'type name 'struct)]
       [env (ce-bind-x env 'size-of name size)]
       [env (ce-bind-x env 'align-of name align)]
       [env (ce-bind-x env 'components name field*)]
       [env (ce-bind-x env 'name-of name c-name)])
  env)
@

<<Insert next field and loop>>=
(let* ([f (car f*)] [t (car t*)]
       [a-f (ce-lookup-x env 'align-of t "Alignment of ~a.~a" name f)]
       [s-f (ce-lookup-x env 'size-of t "Size of field ~a.~a" name f)]
       [start (* a-f (quotient (+ size a-f -1) a-f))]
       [align (max a-f align)]
       [env (ce-bind env (list 'offset-of name f) start)])
  (loop env (cdr f*) (cdr t*) (+ start s-f) align))
@

<<Folding environment routines>>=
(define (ce-add-alias env new old)
   (let ([t (ce-lookup-x env 'type old "type of ~a" old)])
     (case t
       [(const) (let* ([v (ce-lookup-x env 'const old "value of ~a" old)]
                       [env (ce-bind-x env 'type new t)]
                       [env (ce-bind-x env 'const new v)])
                  env)]
       [(type array struct)
           (let* ([c (ce-lookup-x env 'components old
                                "components of ~a" old)]
                  [s (ce-lookup-x env 'size-of old "size of ~a" old)]
                  [a (ce-lookup-x env 'align-of old "align of ~a" old)]
                  [x (ce-lookup-x env 'name-of old "C name of ~a" old)]
                  [env (ce-bind-x env 'type new t)]
                  [env (ce-bind-x env 'size-of new s)]
                  [env (ce-bind-x env 'align-of new a)]
                  [env (ce-bind-x env 'components new c)]
                  [env (ce-bind-x env 'name-of new x)])
              (let loop ([c c] [env env])
                (cond
                  [(null? c) env]
                  [else (let ([o (ce-lookup env (list 'offset-of old (car c))
                                                "offset of ~a in ~a"
                                                (car c) old)])
                          (loop (cdr c)
                                (ce-bind env (list 'offset-of new (car c))
                                         o)))])))]
       [else (error 'qa0 "Internal error in ce-add-alias")])))
@

Do something on each environment entry satisfying given constraint:
<<Folding environment routines>>=
(define (ce-for-each env predicate? proc)
  (let loop ([env env])
    (cond
      [(null? env) #t]
      [(predicate? (caar env) (cdar env)) (proc (caar env) (cdar env))
                                          (loop (cdr env))]
      [else (loop (cdr env))])))
@

\section{COMPLEX EXPANSION}
This section does QCD to [[complex]] conversion.
<<File [[q2complex.ss]]>>=
<<QCD to complex routines>>
(define (qcd->complex ast env)
  <<QCD to complex helpers>>
  (variant-case ast
    [qa0-top (decl*)
      (let loop ([r* '()] [decl* decl*] [env env])
        (cond
          [(null? decl*) (values (make-qa0-top (reverse r*)) env)]
          [else (let-values* ([(d e) (q2c-decl (car decl*) env)])
                  (loop (cons d r*) (cdr decl*) e))]))]))
@

This conversion uses the following generator for register names
<<QCD to complex helpers>>=
(define new-reg (let ([n 0])
                  (lambda () (let ([r (string->symbol (format "~a~a" 'c n))])
                               (set! n (+ n 1))
                               r))))
@
Here we are only interested in [[qa0-proc]], the rest is passed without change
<<QCD to complex helpers>>=
(define (q2c-decl decl env)
  (variant-case decl
    [qa0-proc (attr*
               name
               arg-name* arg-type*
               arg-c-name* arg-c-type*
               code*)
        (q2c-proc attr* name arg-name* arg-type* arg-c-name* arg-c-type*
                  code* env)]         
    [else (values decl env)]))
@
<<QCD to complex helpers>>=
(define (q2c-proc attr* name arg-name* arg-type* arg-c-name* arg-c-type*
                  code* env)
  (let-values* ([(c* env) (q2c-code* code* env)])
     (values (make-qa0-proc attr* name arg-name* arg-type*
                            arg-c-name* arg-c-type* c*)
             env)))
@
<<QCD to complex helpers>>=
(define (q2c-code* code* env)
  (let loop ([r* '()] [code* code*] [env env])
    (cond
      [(null? code*) (values (reverse r*) env)]
      [else (let-values ([(r* env) (q2c-code (car code*) r* env)])
              (loop r* (cdr code*) env))])))
@
<<QCD to complex helpers>>=
(define (q2c-code c r* env)
  (variant-case c
    [qa0-operation (attr* name output* input*)
        (q2c-operation c attr* name output* input* r* env)]
    [qa0-load (attr* type output addr*)
        (q2c-load c attr* type output addr* r* env)]
    [qa0-store (attr* type addr* value)
        (q2c-store c attr* type addr* value r* env)]
    [qa0-loop (attr* var low high code*)
        (q2c-loop c attr* var low high code* r* env)]
    [qa0-if (var true-code* false-code*)
        (q2c-if c var true-code* false-code* r* env)]))
@
Let us do simple cases first.
<<QCD to complex helpers>>=
(define (q2c-if c var true-code* false-code* r* env)
  (let-values* ([(t* env) (q2c-code* true-code* env)]
                [(f* env) (q2c-code* false-code* env)])
    (values (cons (make-qa0-if var t* f*) r*)
            env)))
@
<<QCD to complex helpers>>=
(define (q2c-loop c attr* var low high code* r* env)
  (let-values* ([(c* env) (q2c-code* code* env)])
    (values (cons (make-qa0-loop attr* var low high c*) r*)
            env)))
@
Now, the store handles some types in a special way
<<QCD to complex helpers>>=
(define (q2c-store c attr* type addr* value r* env)
  (case type
    [(qcd-su-n) (q2c-store-su-n attr* addr* value r* env)]
    [(qcd-fermion) (q2c-store-fermion attr* addr* value r* env)]
    [(qcd-half-fermion) (q2c-store-half-fermion attr* addr* value r* env)]
    [else (values (cons c r*) env)]))
@
So does the load. It should be the same set of types as for the store, by
the way.
<<QCD to complex helpers>>=
(define (q2c-load c attr* type output addr* r* env)
  (case type
    [(qcd-su-n) (q2c-load-su-n attr* output addr* r* env)]
    [(qcd-fermion) (q2c-load-fermion attr* output addr* r* env)]
    [(qcd-half-fermion) (q2c-load-half-fermion attr* output addr* r* env)]
    [else (values (cons c r*) env)]))
@

For operations there is also a set of cases requiring special attention
<<QCD to complex helpers>>=
(define (q2c-operation c attr* name output* input* r* env)
  (case name
    [(qcd-project)       (q2c-project       attr* output* input* r* env)]
    [(qcd-unproject)     (q2c-unproject     attr* output* input* r* env)]
    [(qcd-unproject-add) (q2c-unproject-add attr* output* input* r* env)]
    [(qcd-mulf)          (q2c-mulf          attr* output* input* r* env)]
    [(qcd-mulh)          (q2c-mulh          attr* output* input* r* env)]
    [(qcd-mulf-conj)     (q2c-mulf-conj     attr* output* input* r* env)]
    [(qcd-mulh-conj)     (q2c-mulh-conj     attr* output* input* r* env)]
    [(qcd-addf)          (q2c-addf          attr* output* input* r* env)]
    [(qcd-addh)          (q2c-addh          attr* output* input* r* env)]
    [(qcd-maddf)         (q2c-maddf         attr* output* input* r* env)]
    [(qcd-maddh)         (q2c-maddh         attr* output* input* r* env)]
    [else (values (cons c r*) env)]))
@

All stores/load are similar, the only difference is the register renaming model
and the number of [[complex]] numbers to store/load. Fortunately, the number
is computable from the renaming model.
<<QCD to complex helpers>>=
(define (q2c-load-su-n attr* output addr* r* env)
  (q2c-load-xy attr* output addr* '*colors* '*colors*
               'gauge r* env))
(define (q2c-load-fermion attr* output addr* r* env)
  (q2c-load-xy attr* output addr* '*colors* '*fermion-dim*
               'fermion r* env))
(define (q2c-load-half-fermion attr* output addr* r* env)
  (q2c-load-xy attr* output addr* '*colors* '*half-fermion-dim*
               'half-fermion r* env))
(define (q2c-store-su-n attr* addr* value r* env)
  (q2c-store-xy attr* addr* value '*colors* '*colors*
                'gauge r* env))
(define (q2c-store-fermion attr* addr* value r* env)
  (q2c-store-xy attr* addr* value '*colors* '*fermion-dim*
                'fermion r* env))
(define (q2c-store-half-fermion attr* addr* value r* env)
  (q2c-store-xy attr* addr* value '*colors* '*half-fermion-dim*
                'half-fermion r* env))
@

For additions and multiplications the only difference between full and half
fermion is their dimension in the spinor space
<<QCD to complex helpers>>=
(define (q2c-addf attr* output* input* r* env)
  (q2c-addx attr* output* input* '*fermion-dim*
            'fermion r* env))
(define (q2c-addh attr* output* input* r* env)
  (q2c-addx attr* output* input* '*half-fermion-dim*
            'half-fermion r* env))
(define (q2c-mulf attr* output* input* r* env)
  (q2c-mulx attr* output* input* '*fermion-dim*
            'fermion r* env))
(define (q2c-mulh attr* output* input* r* env)
  (q2c-mulx attr* output* input* '*half-fermion-dim*
            'half-fermion r* env))
(define (q2c-mulf-conj attr* output* input* r* env)
  (q2c-mulx-conj attr* output* input* '*fermion-dim*
                 'fermion r* env))
(define (q2c-mulh-conj attr* output* input* r* env)
  (q2c-mulx-conj attr* output* input* '*half-fermion-dim*
                 'half-fermion r* env))
(define (q2c-maddf attr* output* input* r* env)
  (q2c-maddx attr* output* input* '*fermion-dim*
            'fermion r* env))
(define (q2c-maddh attr* output* input* r* env)
  (q2c-maddx attr* output* input* '*half-fermion-dim*
            'half-fermion r* env))
@

\subsection{Loads}
Now, all loads may be reordered as needed, but here we generate them in
the increasing address order.
<<QCD to complex helpers>>=
(define (q2c-load-xy attr* output addr* c-n f-n t r* env)
  (let ([c-n (ce-lookup-x env 'const c-n "Color count")]
        [f-n (ce-lookup-x env 'const f-n "Fermion size")])
    <<Generate complex load>>
    (let c-loop ([c 0] [r* r*] [env env])
      (cond
        [(= c c-n) (values r* env)]
        [else (let f-loop ([f 0] [r* r*] [env env])
                (cond
                  [(= f f-n) (c-loop (+ c 1) r* env)]
                  [else (let-values* ([(r* e) (c-load c f r* env)])
                          (f-loop (+ f 1) r* e))]))]))))
@
Given two coordinates, compute the offset, generate a register name and
produce one load instruction
<<Generate complex load>>=
(define (c-load c f r* env)
  (let-values* ([(x env) (q2c-rename env output t c f)]
                [c-s (ce-lookup-x env 'size-of 'COMPLEX "complex size")]
                [d-s (ce-lookup-x env 'size-of 'complex-double "double size")]
                [c-t (if (= c-s d-s) 'complex-double 'complex-float)]
                [off (* c-s (+ f (* f-n c)))])
    (values (cons (make-qa0-load attr*
                                 c-t
                                 (make-reg x)
                                 (append addr* (list (make-c-expr-number off))))
                  r*)
            env)))
@

\subsection{Stores}
<<QCD to complex helpers>>=
(define (q2c-store-xy attr* addr* value c-n f-n t r* env)
  (let ([c-n (ce-lookup-x env 'const c-n "Color count")]
        [f-n (ce-lookup-x env 'const f-n "Fermion size")])
    <<Generate complex store>>
    (let c-loop ([c 0] [r* r*] [env env])
      (cond
        [(= c c-n) (values r* env)]
        [else (let f-loop ([f 0] [r* r*] [env env])
                (cond
                  [(= f f-n) (c-loop (+ c 1) r* env)]
                  [else (let-values* ([(r* e) (c-store c f r* env)])
                          (f-loop (+ f 1) r* e))]))]))))
@
<<Generate complex store>>=
(define (c-store c f r* env)
  (let-values* ([(x env) (q2c-rename env value t c f)]
                [c-s (ce-lookup-x env 'size-of 'COMPLEX "complex size")]
                [d-s (ce-lookup-x env 'size-of 'complex-double "double size")]
                [c-t (if (= c-s d-s) 'complex-double 'complex-float)]
                [off (* c-s (+ f (* f-n c)))])
    (values (cons (make-qa0-store attr*
                                  c-t
                                  (append addr* (list (make-c-expr-number off)))
                                  (make-reg x))
                  r*)
            env)))
@

\subsection{Addition and Multiplication}
<<QCD to complex helpers>>=
(define (q2c-addx attr* output* input* f-n t r* env)
  <<Generate complex add>>
  (q2c-check-list output* = 1 "QCD add outputs")
  (q2c-check-list input* = 2 "QCD add inputs")
  (let ([c-n (ce-lookup-x env 'const '*colors* "Color count")]
        [f-n (ce-lookup-x env 'const f-n "Field dimension")])
    (let c-loop ([c 0] [r* r*] [env env])
      (cond
        [(= c c-n) (values r* env)]
        [else (let f-loop ([f 0] [r* r*] [env env])
                (cond
                  [(= f f-n) (c-loop (+ c 1) r* env)]
                  [else (let-values* ([(r* env) (complex-add c f r* env)])
                           (f-loop (+ f 1) r* env))]))]))))
                                  
@
<<Generate complex add>>=
(define (complex-add c f r* env)
  (let-values* ([(a env) (q2c-rename env (car input*) t c f)]
                [(b env) (q2c-rename env (cadr input*) t c f)]
                [(d env) (q2c-rename env (car output*) t c f)])
    (values (cons (make-qa0-operation attr*
                                      'complex-add
                                      (list (make-reg d))
                                      (list (make-reg a) (make-reg b)))
                  r*)
            env)))
@

<<QCD to complex helpers>>=
(define (q2c-maddx attr* output* input* f-n t r* env)
  <<Generate complex multiply-add>>
  (q2c-check-list output* = 1 "QCD madd outputs")
  (q2c-check-list input* = 3 "QCD madd inputs")
  (let ([c-n (ce-lookup-x env 'const '*colors* "Color count")]
        [f-n (ce-lookup-x env 'const f-n "Field dimension")])
    (let c-loop ([c 0] [r* r*] [env env])
      (cond
        [(= c c-n) (values r* env)]
        [else (let f-loop ([f 0] [r* r*] [env env])
                (cond
                  [(= f f-n) (c-loop (+ c 1) r* env)]
                  [else (let-values* ([(r* env) (complex-madd c f r* env)])
                           (f-loop (+ f 1) r* env))]))]))))
                                  
@
<<Generate complex multiply-add>>=
(define (complex-madd c f r* env)
  (let-values* ([(a) (car input*)]
                [(b env) (q2c-rename env (cadr input*) t c f)]
                [(r env) (q2c-rename env (caddr input*) t c f)]
                [(x env) (q2c-rename env (car output*) t c f)])
    (values (cons (make-qa0-operation attr*
                                      'complex-rmadd
                                      (list (make-reg x))
                                      (list a (make-reg b) (make-reg r)))
                  r*)
            env)))
@

<<QCD to complex helpers>>=
(define (q2c-mul-g attr* output* input* f-n t op-0 op-k u-get r* env)
  (q2c-check-list output* = 1 "QCD mul outputs")
  (q2c-check-list input* = 2 "QCD mul inputs")
  (let ([c-n (ce-lookup-x env 'const '*colors* "Color count")]
        [f-n (ce-lookup-x env 'const f-n "Field dimension")]
        [r-a (car input*)]
        [r-b (cadr input*)]
        [r-r (car output*)])
     <<Generate complex multiply>>
     (if (= c-n 1) (s-mul-z r* env)
         (let-values* ([(r* env r-x) (s-mul-1 r* env)])
           (let loop ([c 1] [r* r*] [env env] [r-x r-x])
             (cond
               [(= c (- c-n 1))
                 (let-values* ([(r* env r-x) (s-madd-x r-x r-r c r* env)])
                   (values r* env))]
               [else
                 (let-values* ([(r* env r-x) (s-madd-x r-x (new-reg) c r* env)])
                   (loop (+ c 1) r* env r-x))]))))))
@
<<Generate complex multiply>>=
(define (s-mul-z r* env)
  (let-values* ([(a env) (u-get r-a 0 0 env)])
    (let loop ([f 0] [r* r*] [env env])
      (cond
        [(= f f-n) (values r* env)]
        [else
          (let-values* ([(b env) (q2c-rename env r-b t 0 f)]
                        [(z env) (q2c-rename env r-r t 0 f)])
            (loop (+ f 1)
                  (cons (make-qa0-operation attr*
                                            op-0
                                            (list (make-reg z))
                                            (list (make-reg a) (make-reg b)))
                        r*)
                  env))]))))
@
<<Generate complex multiply>>=
(define (s-mul-1 r* env)
  (let ([q (new-reg)])
    (let x-loop ([x 0] [r* r*] [env env])
      (cond
        [(= x c-n) (values r* env q)]
        [else
          (let y-loop ([y 0] [r* r*] [env env])
            (cond
              [(= y f-n) (x-loop (+ x 1) r* env)]
              [else
                (let-values* ([(q-v env) (q2c-rename env q t x y)]
                              [(a-v env) (u-get r-a x 0 env)]
                              [(b-v env) (q2c-rename env r-b t 0 y)])
                  (y-loop (+ y 1)
                          (cons (make-qa0-operation attr*
                                                    op-0
                                                    (list (make-reg q-v))
                                                    (list (make-reg a-v)
                                                          (make-reg b-v)))
                                 r*)
                          env))]))]))))
@
<<Generate complex multiply>>=
(define (s-madd-x r-x r-r c r* env)
  (let x-loop ([x 0] [r* r*] [env env])
    (cond
      [(= x c-n) (values r* env r-r)]
      [else
        (let y-loop ([y 0] [r* r*] [env env])
          (cond
            [(= y f-n) (x-loop (+ x 1) r* env)]
            [else
              (let-values* ([(q-v env) (q2c-rename env r-x t x y)]
                            [(r-v env) (q2c-rename env r-r t x y)]
                            [(a-v env) (u-get r-a x c env)]
                            [(b-v env) (q2c-rename env r-b t c y)])
                (y-loop (+ y 1)
                        (cons (make-qa0-operation attr*
                                                  op-k
                                                  (list (make-reg r-v))
                                                  (list (make-reg a-v)
                                                        (make-reg b-v)
                                                        (make-reg q-v)))
                              r*)
                        env))]))])))
@

Two multiplication routines:
<<QCD to complex helpers>>=
(define (q2c-mulx attr* output* input* f-n t r* env)
  (q2c-mul-g attr* output* input* f-n t
             'complex-mul 'complex-madd
             (lambda (r i j env) (q2c-rename env r 'gauge i j))
	     r* env))
(define (q2c-mulx-conj attr* output* input* f-n t r* env)
  (q2c-mul-g attr* output* input* f-n t
             'complex-cmul 'complex-cmadd
             (lambda (r i j env) (q2c-rename env r 'gauge j i))
	     r* env))
@

\subsection{Syntax check}
We should have lists of certain sizes in various places. Here we check that
the size is corrent.
<<QCD to complex helpers>>=
(define (q2c-check-list x* op size msg)
  (if (not (op (length x*) size))
      (error 'qcd->complex "ERROR: ~a" msg)))
@
\subsection{Accessing components}
This function finds a name of the complex component for a given QCD register
<<QCD to complex helpers>>=
(define (q2c-rename env base type i-a i-b)
  (let ([key (list 'qcd->complex base type i-a i-b)])
    (ce-search env key
       (lambda (val)
         (values val env))
       (lambda ()
         (let* ([r (new-reg)]
                [env (ce-bind env key r)])
           (values r env))))))
@
\subsection{Attributes access}
Very much the environment, but records have different representation here.
<<QCD to complex routines>>=
(define (attr-search attr* key found missed)
  (let loop ([attr* attr*])
    (cond
      [(null? attr*) (missed)]
      [else (variant-case (car attr*)
              [qa0-attr (name value*) (if (eq? key name) (found value*)
                                          (loop (cdr attr*)))])])))
@
<<QCD to complex routines>>=
(define (attr-lookup attr* key msg . arg*)
  (attr-search attr* key
               (lambda (v*) v*)
               (lambda () (apply error 'qa0 msg arg*))))
@

\subsection{Gamma projection and unprojection}

<<QCD to complex helpers>>=
(define (q2c-project attr* output* input* r* env)
  (q2c-check-list output* = 1 "QCD gamma projection result")
  (q2c-check-list input* = 1 "QCD gamma projection source")
  (let* ([kind (attr-lookup attr* 'project "qcd-project")]
         [op* (ce-lookup env `(project ,@kind) "project op-table for ~a" kind)]
         [c-n (ce-lookup-x env 'const '*colors* "Color count")]
         [h-n (/ (ce-lookup-x env 'const '*fermion-dim* "Fermion dim") 2)]
         [r-r (car output*)]
         [r-a (car input*)])
    <<Projection helpers>>
    (let c-loop ([c 0] [r* r*] [env env])
      (cond
        [(= c c-n) (values r* env)]
        [else (let h-loop ([h 0] [op* op*] [r* r*] [env env])
                (cond
                  [(null? op*) (c-loop (+ c 1) r* env)]
                  [else (let-values* ([(r* env) (proj c h (car op*) r* env)])
                          (h-loop (+ h 1) (cdr op*) r* env))]))]))))
@

Build one component of the half-fermion
<<Projection helpers>>=
(define (proj c h op r* env)
  (q2c-check-list op = 4 "Projection operation")
  (let-values* ([op-0 (car op)] [(f-0) (cadr op)]
                [(a-0 env) (q2c-rename env r-a 'fermion c f-0)]
                [op-1 (caddr op)] [(f-1) (cadddr op)]
                [(a-1 env) (q2c-rename env r-a 'fermion c f-1)]
                [cmd (binary-cmd op-0 op-1)]
                [(r env) (q2c-rename env r-r 'half-fermion c h)])
    (values (cons (make-qa0-operation attr*
                                      cmd
                                      (list (make-reg r))
                                      (list (make-reg a-0) (make-reg a-1)))
                  r*)
            env)))
@

<<Projection helpers>>=
(define (binary-cmd op-0 op-1)
   (case op-0
     [(plus-one)
       (case op-1
         [(plus-one) 'complex-add]
         [(minus-one) 'complex-sub]
         [(plus-i) 'complex-add-i]
         [(minus-i) 'complex-sub-i]
         [else (error 'qa0 "Unknown second factor (~a ~a)" op-0 op-1)])]
     [else (error 'qa0 "Unknown first factor (~a ~a)" op-0 op-1)]))
@

<<QCD to complex helpers>>=
(define (q2c-unproject attr* output* input* r* env)
  (q2c-check-list output* = 1 "QCD gamma unprojection result")
  (q2c-check-list input* = 1 "QCD gamma unprojection source")
  (let* ([kind (attr-lookup attr* 'unproject "qcd-unproject")]
         [op* (ce-lookup env `(unproject ,@kind) "unproj op-table for ~a" kind)]
         [c-n (ce-lookup-x env 'const '*colors* "Color count")]
         [f-n (ce-lookup-x env 'const '*fermion-dim* "Fermion dim")]
         [r-r (car output*)]
         [r-a (car input*)])
    <<Unproject helpers>>
    (let c-loop ([c 0] [r* r*] [env env])
      (cond
        [(= c c-n) (values r* env)]
        [else (let f-loop ([f 0] [op* op*] [r* r*] [env env])
                (cond
                  [(null? op*) (c-loop (+ c 1) r* env)]
                  [else (let-values* ([(r* env) (unproj c f (car op*) r* env)])
                          (f-loop (+ f 1) (cdr op*) r* env))]))]))))
@

<<Unproject helpers>>=
(define (unproj c f op r* env)
  (q2c-check-list op = 2 "Unprojection operation")
  (let-values* ([opcode (car op)] [(component) (cadr op)]
                [(a env) (q2c-rename env r-a 'half-fermion c component)]
                [cmd (unary-cmd opcode)]
                [(r env) (q2c-rename env r-r 'fermion c f)])
    (values (cons (make-qa0-operation attr*
                                      cmd
                                      (list (make-reg r))
                                      (list (make-reg a)))
                  r*)
            env)))
@

<<Unproject helpers>>=
(define (unary-cmd name)
  (case name
    [(plus-one) 'complex-move]
    [(minus-one) 'complex-neg]
    [(plus-i) 'complex-times-plus-i]
    [(minus-i) 'complex-times-minus-i]
    [else (error 'qa0 "Unknown unproject operation ~a" name)]))
@

<<QCD to complex helpers>>=
(define (q2c-unproject-add attr* output* input* r* env)
  (q2c-check-list output* = 1 "QCD gamma unproject-add result")
  (q2c-check-list input* = 2 "QCD gamma unproject-add sources")
  (let* ([kind (attr-lookup attr* 'unproject "qcd-unproject-add")]
         [op* (ce-lookup env `(unproject ,@kind) "unproj op-table for ~a" kind)]
         [c-n (ce-lookup-x env 'const '*colors* "Color count")]
         [r-r (car output*)]
         [r-a (car input*)]
         [r-b (cadr input*)])
    <<Unproject-add helpers>>
    (let c-loop ([c 0] [r* r*] [env env])
      (cond
        [(= c c-n) (values r* env)]
        [else (let f-loop ([f 0] [op* op*] [r* r*] [env env])
                (cond
                  [(null? op*) (c-loop (+ c 1) r* env)]
                  [else (let-values* ([(r* env) (upa c f (car op*) r* env)])
                          (f-loop (+ f 1) (cdr op*) r* env))]))]))))
@
<<Unproject-add helpers>>=
(define (upa c f op r* env)
  (q2c-check-list op = 2 "Unprojection operation")
  (let-values* ([(a env) (q2c-rename env r-a 'fermion c f)]
                [opcode (car op)] [(component) (cadr op)]
                [(b env) (q2c-rename env r-b 'half-fermion c component)]
                [cmd (add-cmd opcode)]
                [(r env) (q2c-rename env r-r 'fermion c f)])
    (values (cons (make-qa0-operation attr*
                                      cmd
                                      (list (make-reg r))
                                      (list (make-reg a) (make-reg b)))
                  r*)
            env)))
@

<<Unproject-add helpers>>=
(define (add-cmd name)
  (case name
    [(plus-one) 'complex-add]
    [(minus-one) 'complex-sub]
    [(plus-i) 'complex-add-i]
    [(minus-i) 'complex-sub-i]
    [else (error 'qa0 "Unknown unproject operation ~a" name)]))
@

\section{TREE PRINTING}
To make the output of various phases easier to read, here is an printer for the
tree.
<<File [[qa0print.ss]]>>=
(define (print-tree ast)
  <<Print routines>>
  (variant-case ast
    [qa0-top (decl*) (for-each (lambda (decl) (print-decl decl 0)) decl*)]))
@

<<Print routines>>=
(define (print-decl decl level)
  (variant-case decl
    [qa0-alias (old-name new-name)
       (print-alias level old-name new-name)]
    [qa0-const (name value)
       (print-const level name value)]
    [qa0-struct (name c-name field-name* field-type* field-c-name*)
       (print-struct level name c-name field-name* field-type* field-c-name*)]
    [qa0-array (name c-name base-name size)
       (print-array level name c-name base-name size)]
    [qa0-proc (attr* name arg-name* arg-type* arg-c-name* arg-c-type* code*)
       (print-proc level attr* name
                   arg-name* arg-type* arg-c-name* arg-c-type* code*)]
    [qa0-repeat-list (id value* body*)
       (print-repeat-list level id value* body*)]
    [qa0-repeat-range (id low high body*)
       (print-repeat-range level id low high body*)]))
@

<<Print routines>>=
(define (print-start level)
  (do ([i 0 (+ i 1)])
      [(= i level)]
    (printf "  ")))
@

<<Print routines>>=
(define (print-alias level old-name new-name)
  (print-start level)
  (printf "Alias of ~a is ~a~%" old-name new-name))
@

<<Print routines>>=
(define (print-const level name value)
  (print-start level)
  (printf "Constant ~a = " name)
  (print-input value)
  (printf "~%"))
@

<<Print routines>>=
(define (print-struct level name c-name field-name* field-type* field-c-name*)
  (print-start level)
  (printf "Structure ~a ~s:~%" name c-name)
  (for-each (lambda (name type c-name)
               (print-start (+ level 1))
               (printf "~a ~a ~s~%" name type c-name))
            field-name* field-type* field-c-name*))
@

<<Print routines>>=
(define (print-array level name c-name base-name size)
  (print-start level)
  (printf "Array ~a ~s is ~a of " name c-name base-name)
  (print-input size)
  (printf "~%"))
@

<<Print routines>>=
(define (print-proc level attr* name
                   arg-name* arg-type* arg-c-name* arg-c-type* code*)
  (print-start level)
  (printf "Procedure ~a attrs " name)
  (print-attr* attr*)
  (printf "~%")
  (for-each (lambda (n t c-n c-t)
               (print-start (+ level 3))
               (printf "[~a ~a ~s ~s]~%" n t c-n c-t))
            arg-name* arg-type* arg-c-name* arg-c-type*)
  (print-code* (+ level 1) code*)
  (print-start level)
  (printf "Procedure ~a end~%" name))
@

<<Print routines>>=
(define (print-repeat-list level id value* body*)
  (print-start level)
  (printf "Repeat ~a in ~s~%" id value*)
  (for-each (lambda (decl) (print-decl (+ level 1) decl)) body*)
  (print-start level)
  (printf "Repeat ~a end~%" id))
@

<<Print routines>>=
(define (print-repeat-range level id low high body*)
  (print-start level)
  (printf "Repeat ~a from " id)
  (print-input low)
  (printf " to ")
  (print-input high)
  (printf "~%")
  (for-each (lambda (decl) (print-decl (+ level 1) decl)) body*)
  (print-start level)
  (printf "Repeat ~a end~%" id))
@

<<Print routines>>=
(define (print-code* level code*)
  (for-each (lambda (code) (print-code level code)) code*))
@

<<Print routines>>=
(define (print-code level code)
  (variant-case code
    [qa0-operation (attr* name output* input*)
        (print-operation level attr* name output* input*)]
    [qa0-load (attr* type output addr*)
        (print-load level attr* type output addr*)]
    [qa0-store (attr* type addr* value)
        (print-store level attr* type addr* value)]
    [qa0-loop (attr* var low high code*)
        (print-loop level attr* var low high code*)]
    [qa0-if (var true-code* false-code*)
        (print-if level var true-code* false-code*)]
    [qa0-macro-list (id value* code*)
        (print-macro-list level id value* code*)]
    [qa0-macro-range (id low high code*)
        (print-macro-range level id low high code*)]))
@

<<Print routines>>=
(define (print-operation level attr* name output* input*)
  (print-start level)
  (printf "op ")
  (print-attr* attr*)
  (printf " (")
  (print-output* output*)
  (printf ") <- ~a (" name)
  (print-input* input*)
  (printf ")~%"))
@
<<Print routines>>=
(define (print-load level attr* type output addr*)
  (print-start level)
  (printf "load ~a " type)
  (print-attr* attr*)
  (printf " ")
  (print-output output)
  (printf " <- Mem{")
  (print-input* addr*)
  (printf "}~%"))
@
<<Print routines>>=
(define (print-store level attr* type addr* value)
  (print-start level)
  (printf "store ~a " type)
  (print-attr* attr*)
  (printf " Mem{")
  (print-input* addr*)
  (printf "} <- ")
  (print-input value)
  (printf "~%"))
@

<<Print routines>>=
(define (print-loop level attr* var low high code*)
  (print-start level)
  (printf "Loop ")
  (print-attr* attr*)
  (printf " ~a from " (reg->name var))
  (print-input low)
  (printf " to ")
  (print-input high)
  (printf "~%")
  (print-code* (+ level 1) code*)
  (print-start level)
  (printf "Loop ~a end~%" (reg->name var)))
@
<<Print routines>>=
(define (print-if level var true-code* false-code*)
  (print-start level)
  (printf "If ")
  (print-input var)
  (printf " then~%")
  (print-code* (+ level 1) true-code*)
  (print-start level)
  (printf "else~%")
  (print-code* (+ level 1) false-code*)
  (print-start level)
  (printf "fi~%"))
@

<<Print routines>>=
(define (print-macro-list level id value* body*)
  (print-start level)
  (printf "Macro ~a in ~s~%" id value*)
  (print-code* (+ level 1) body*)
  (print-start level)
  (printf "Macro ~a end~%" id))
@

<<Print routines>>=
(define (print-macro-range level id low high body*)
  (print-start level)
  (printf "Macro ~a from " id)
  (print-input low)
  (printf " to ")
  (print-input high)
  (printf "~%")
  (print-code* (+ level 1) body*)
  (print-start level)
  (printf "Macro ~a end~%" id))
@

<<Print routines>>=
(define (print-input* input*) (print-list print-input input*))
(define (print-output* output*) (print-list print-output output*))
(define (print-attr* attr*)
  (printf "(") (print-list print-attr attr*) (printf ")"))
@

<<Print routines>>=
(define (print-list print-it l*)
  (if (null? l*) #f
      (begin (print-it (car l*))
             (do ([l* (cdr l*) (cdr l*)])
                 [(null? l*)]
               (printf " ")
               (print-it (car l*))))))
@

<<Print routines>>=
(define (print-attr attr)
  (variant-case attr
    [qa0-attr (name value*)
       (if (null? value*) (printf "~a" name)
           (begin (printf "[~a " name)
                  (print-list write value*)
                  (printf "]")))]))
@

<<Print routines>>=
(define (print-output out)
  (variant-case out
    [reg (name) (printf "~a" name)]))
@

<<Print routines>>=
(define (print-input in)
  (variant-case in
    [reg (name) (printf "[reg ~a]" name)]
    [else (printf "[const ") (print-cexpr in) (printf "]")]))
@

<<Print routines>>=
(define (print-cexpr ce)
  (variant-case ce
    [c-expr-quote (literal) (printf "'~a" literal)]
    [c-expr-id (id) (printf "~a" id)]
    [c-expr-number (number) (printf "~a" number)]
    [c-expr-string (string) (printf "~s" string)]
    [c-expr-op (name c-expr*) (printf "(~a " name)
                              (print-list print-cexpr c-expr*)
                              (printf ")")]))
@

\section{BACK ENDS}
The call interface to the back end is simple: we hide everything into the
environment and simply lookup relevant pieces here:
<<File [[backends.ss]]>>=
(define (complex->back-end ast env)
  ((ce-lookup env 'back-end "Back end transformer not found") ast env))
(define (emit-back-end ast env)
  ((ce-lookup env 'be-emit "Code emitter not found") ast env))
(define new-var
  (let ([x 0]) (lambda () (let ([s (format "g~a" x)])
                            (set! x (+ x 1))
                            s))))
@

\subsection{Generic 32 bit back end}
<<File [[backends.ss]]>>=
(define (machine-*-32 env op* load*)
  (let* ([env (ce-add-type env 'int            "int"              4  4)]
         [env (ce-add-type env 'pointer        "unsigned char *"  4  4)]
         [env (ce-add-type env 'float          "float"            4  4)]
         [env (ce-add-type env 'double         "double"           8  8)]
         [env (ce-add-type env 'vector-float   "vector float"     8  8)]
         [env (ce-add-type env 'vector-double  "vector double"   16 16)]
         [env (ce-add-type env 'complex-float  "float _Complex"   8  8)]
         [env (ce-add-type env 'complex-double "double _Complex" 16 16)]
         [env (ce-add-const env '*colors*            3)]
         [env (ce-add-const env '*DIM*               4)]
         [env (ce-add-const env '*fermion-dim*       4)]
         [env (ce-add-const env '*half-fermion-dim*  2)])
    (let loop ([env env] [op* op*])
      (cond
        [(null? op*)
          (let loop ([env env] [load* load*])
            (cond
              [(null? load*) env]
              [else (loop (ce-bind-x env 'be-load-type (caar load*)
                                     (cadar load*))
                          (cdr load*))]))]
        [else (loop (ce-bind-x env 'be-op-type* (caar op*) (cdar op*))
                    (cdr op*))]))))
@

Get the types of output registers in an operation.
<<File [[backends.ss]]>>=
(define (be-out-type* env name)
  (ce-lookup-x env 'be-op-type* name
               "Unknown operation ~a in be-op-type*" name))

(define (be-load-type env load-op)
  (ce-lookup-x env 'be-load-type load-op
               "Unknown load operation ~a in be-load-type" load-op))
@


\subsection{C99 back end}
Conversion to the back-end is trivial for C99. We postpone naming registers to
avoid going through the code twice.
<<File [[backends.ss]]>>=
(define (c99-back-end ast env) (values ast env))
@

<<C99 back-end helpers>>=
(define (proc-outputs arg-name* arg-type* code* env)
  <<C99 output helpers>>
  (let* ([env (collect-args arg-name* arg-type* env)]
  	 [env (collect-output* code* env)])
    env))
@

<<C99 output helpers>>=
(define (collect-args arg-name* arg-type* env)
  (cond
    [(null? arg-name*) env]
    [else (let* ([env (ce-bind-x env 'back-end (car arg-name*)
                                 (list (new-var) (car arg-type*)))])
            (collect-args (cdr arg-name*) (cdr arg-type*) env))]))
@

<<C99 output helpers>>=
(define (collect-output* code* env)
  (cond
    [(null? code*) env]
    [else (collect-output* (cdr code*) (c99-output-code (car code*) env))]))
@

<<C99 output helpers>>=
(define (c99-output-code code env)
  (variant-case code
    [qa0-operation (name output*)
       (add-output* output* (be-out-type* env name) env)]
    [qa0-load (output type) (add-output output (be-load-type env type) env)]
    [qa0-store () env]
    [qa0-loop (var code*) (let ([env (collect-output* code* env)])
                            (add-output var 'int env))]
    [qa0-if (true-code* false-code*)
       (let* ([env (collect-output* true-code* env)]
              [env (collect-output* false-code* env)])
         env)]))
@

<<C99 output helpers>>=
(define (add-output* output* type* env)
  (cond
    [(null? output*) env]
    [else (add-output* (cdr output*) (cdr type*)
                       (add-output (car output*) (car type*) env))]))
@

<<C99 output helpers>>=
(define (add-output output type env)
  (variant-case output
    [reg (name)
      (ce-search env (list 'back-end name)
                (lambda (v) env)
                (lambda () (ce-bind-x env 'back-end name
                                      (list (new-var) type))))]))
@

<<C99 back-end helpers>>=
(define (input-code* code* env)
  <<C99 input helpers>>=
  (for-each (lambda (code) (input-code code env)) code*))
@

<<C99 input helpers>>=
(define (input-code code env)
  (variant-case code
    [qa0-operation (input*) (c99-input* input* env)]
    [qa0-load (addr*) (c99-input* addr* env)]
    [qa0-store (addr* value) (c99-input* addr* env) (c99-input value env)]
    [qa0-loop (low high code*) (input-code* code* env)
      (c99-input low env) (c99-input high env)]
    [qa0-if (var true-code* false-code*) (c99-input var env)
      (input-code* true-code* env) (input-code* false-code* env)]))
@

<<C99 input helpers>>=
(define (c99-input* input* env)
  (for-each (lambda (input) (c99-input input env)) input*))
@

<<C99 input helpers>>=
(define (c99-input input env)
  (variant-case input
    [reg (name)
      (ce-lookup-x env 'back-end name
                   "C99 looking for definition of ~a" name)]
    [else #t]))
@


Build C99 code of the the input. We only emit procedures here and expect
another function to produce type declarations and function prototypes.
<<File [[backends.ss]]>>=
(define (c99-emit qa0 env)
  <<C99 emit helpers>>
  (variant-case qa0
    [qa0-top (decl*) (let loop ([decl* decl*])
                       (cond
                         [(null? decl*)]
                         [else (emit-decl (car decl*)) (loop (cdr decl*))]))]))
@

Make the emitted code look nice:
<<C99 emit helpers>>=
(define (emit-indent n)
   (cond
     [(zero? n)]
     [else (printf "  ") (emit-indent (- n 1))]))
(define (do-emit n fmt . arg*)
  (emit-indent n)
  (apply printf fmt arg*)
  (newline))
@

<<C99 emit helpers>>=
(define (emit-decl decl)
  <<C99 back-end helpers>>
  (variant-case decl
    [qa0-proc (attr* name arg-name* arg-type* arg-c-name* arg-c-type* code*)
      (let ([env (proc-outputs arg-name* arg-type* code* env)])
         (input-code* code* env)
;         (printf "~%**** Environment in back end~%")
;         (for-each (lambda (r)
;	             (printf "   ~s : ~s~%" (car r) (cdr r))) env)
;         (printf "~%*****~%~%")
         (emit-proc attr* name
                    arg-name* arg-type*
                    arg-c-name* arg-c-type*
                    code* env))]
    [else #t]))
@

<<C99 emit helpers>>=
(define (emit-proc attr* name
                   arg-name* arg-type*
                   arg-c-name* arg-c-type*
                   code* env)
  (let ([cf? (attr-search attr* 'count-flops (lambda (v) #t) (lambda () #f))]
        [counter (new-var)])
    (printf "/* emitting procedure ~a */~%" name)
    (emit-proc-decl cf? attr* name arg-c-name* arg-c-type* env)
    (printf "{~%")
    (if cf? (do-emit 1 "int ~a = 0;" counter))
    (emit-variables env)
    (emit-param* arg-name* arg-c-name* env)
    (emit-code* 1 code* env cf? counter 0)
    (if cf? (do-emit 1 "return ~a;" counter))
    (printf "}~%~%")
))
@

<<C99 emit helpers>>=
(define (emit-proc-decl count-flops? attr* name arg-c-name* arg-c-type* env)
  (printf "~a~%~a" (if count-flops? "int" "void")
          (build-proc-name (attr-lookup attr* 'stem
                                        "missing stem in proc ~a" name) env))
  (if (null? arg-c-name*) (printf "(void)~%")
      (begin (printf "(")
             (let loop ([name* arg-c-name*] [type* arg-c-type*])
               (cond
                 [(null? name*)]
                 [else (printf "~a~a ~a" (if (eq? name* arg-c-name*) "" ", ")
                               (car type*) (car name*))
                       (loop (cdr name*) (cdr type*))]))
             (printf ")~%"))))
@

<<C99 emit helpers>>=
(define (emit-variables env)
  (ce-for-each env (lambda (k v) (and (list? k) (eq? (car k) 'back-end)))
    (lambda (k v)
      (do-emit 1  "~a ~a;"
               (ce-lookup-x env 'name-of (cadr v) "c99 type for ~a" v)
               (car v)))))
@

<<C99 emit helpers>>=
(define (emit-param* arg-name* arg-c-name* env)
   (do-emit 0 "")
   (let loop ([name* arg-name*] [c-name* arg-c-name*])
     (cond
       [(null? name*) (do-emit 0 "")]
       [else (let ([rt (ce-lookup-x env 'back-end (car name*)
                                    "C99 name for ~a" (car name*))])
               (do-emit 1 "~a = (~a)~a;"
                        (car rt)
                        (ce-lookup-x env 'name-of (cadr rt)
                                     "C99 type for ~a" rt)
		        (car c-name*))
               (loop (cdr name*) (cdr c-name*)))])))
@

<<C99 emit helpers>>=
(define (emit-code* level code* env count-flops? counter f)
   (cond
     [(null? code*) (emit-count level count-flops? counter f)]
     [else (let ([f (emit-code level (car code*) env count-flops? counter f)])
             (emit-code* level (cdr code*) env count-flops? counter f))]))
                    
@

<<C99 emit helpers>>=
(define (emit-count level count-flops? counter flops)
  (if (and count-flops? (not (zero? flops)))
      (do-emit level "~a += ~a;" counter flops)))
@

<<C99 emit helpers>>=
(define (emit-code l code env count-flops? counter flops) ; => flops'
  (variant-case code
    [qa0-operation (name output* input*)
       (emit-op l name output* input* env flops)]
    [qa0-load (type output addr*)
       (emit-load l type output addr* env flops)]
    [qa0-store (type addr* value)
       (emit-store l type addr* value env flops)]
    [qa0-if (var true-code* false-code*)
       (emit-if l var true-code* false-code* env count-flops? counter flops)]
    [qa0-loop (var low high code*)
       (emit-loop l var low high code* env count-flops? counter flops)]))
@

The emit routines for five codes
<<C99 emit helpers>>=
(define (emit-loop l var low high code* env count-flops? counter flops)
  (cond
    [(null? code*) (do-emit l "~a = ~a; /* empty loop */" var high) flops]
    [else (let ([v (preemit-output var env)]
                [lo (preemit-input low env)]
                [hi (preemit-input high env)])
            (emit-count l count-flops? counter flops)
            (do-emit l "for (~a = ~a; ~a < ~a; ~a++) {" v lo v hi v)
            (emit-code* (+ l 1) code* env count-flops? counter 0)
            (do-emit l "}")
            0)]))
@

<<C99 emit helpers>>=
(define (emit-if l var true-code* false-code* env count-flops? counter flops)
  (emit-count l count-flops? counter flops)
  (do-emit l "if (~a) {" (preemit-input var env))
  (emit-code* (+ l 1) true-code* env count-flops? counter 0)
  (if (not (null? false-code*))
      (begin (do-emit l "} else {")
             (emit-code* (+ l 1) false-code* env count-flops? counter 0)))
  (do-emit l "}")
  0)
@

<<C99 emit helpers>>=
(define (emit-store l type addr* value env flops)
  (do-emit l "*(~a *)(~a) = ~a;"
           (ce-lookup-x env 'name-of type "C99 name of type ~a" type)
           (preemit-addr* addr* env)
           (preemit-input value env))
  flops)
@

<<C99 emit helpers>>=
(define (emit-load l type output addr* env flops)
  (do-emit l "~a = *(~a *)(~a);"
           (preemit-output output env)
           (ce-lookup-x env 'name-of type "C99 name of type ~a" type)
           (preemit-addr* addr* env))
  flops)
@

<<C99 emit helpers>>=
(define (preemit-addr* addr* env)
  (let loop ([v (preemit-input (car addr*) env)] [addr* (cdr addr*)])
    (cond
      [(null? addr*) v]
      [else (loop (format "~a + ~a" v (preemit-input (car addr*) env))
                  (cdr addr*))])))
@
<<C99 emit helpers>>=
(define (preemit-input in env)
  (variant-case in
    [reg (name) (car (ce-lookup-x env 'back-end name
                                  "C99 of reg ~a at input" name))]
    [c-expr-number (number) number]))
@

<<C99 emit helpers>>=
(define (preemit-output out env)
  (variant-case out
    [reg (name) (car (ce-lookup-x env 'back-end name
                                  "C99 of reg ~a at output" name))]))
@

<<C99 emit helpers>>=
(define (emit-op l name output* input* env flops)
  <<C99 emit-op helpers>>
  (let ([out* (map (lambda (out) (preemit-output out env)) output*)]
        [in* (map (lambda (in) (preemit-input in env)) input*)])
    (case name
      <<C99 emit-op operations>>
      [else (do-emit l "/* XXX op: ~a, out* ~a, in* ~a */" name out* in*)
            (+ flops 1)])))
@

<<C99 emit-op helpers>>=
(define (check-put* p* size)
   (if (not (= size (length p*)))
       (error 'c99-backend "Illformed operation: ~a <- ~a ~a"
              output* name input*)))
@

Moves may occur for many reasons, they are likely to be eliminated by the
compiler anyway. We don't attempt to do anything about them here.
<<C99 emit-op operations>>=
[(int-move double-move complex-move pointer-move)
   (check-put* out* 1) (check-put* in* 1)
   (do-emit l "~a = ~a;" (car out*) (car in*))
   flops]
@

On pointers there is only one operation. We may have many inputs here.
<<C99 emit-op operations>>=
[(pointer-add) (check-put* out* 1)
  (do-emit l "~a = ~a;" (car out*) (preemit-addr* input* env))
  flops]
@

Integer operations.
<<C99 emit-op operations>>=
[(int-mul) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a * ~a;" (car out*) (car in*) (cadr in*))
  flops]
@

<<C99 emit-op operations>>=
[(int-div) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a / ~a;" (car out*) (car in*) (cadr in*))
  flops]
@

<<C99 emit-op operations>>=
[(int-mod) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a % ~a;" (car out*) (car in*) (cadr in*))
  flops]
@

<<C99 emit-op operations>>=
[(int-add) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a + ~a;" (car out*) (car in*) (cadr in*))
  flops]
@

<<C99 emit-op operations>>=
[(int-sub) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a - ~a;" (car out*) (car in*) (cadr in*))
  flops]
@

<<C99 emit-op operations>>=
[(int-neg) (check-put* out* 1) (check-put* in* 1)
  (do-emit l "~a = - ~a;" (car out*) (car in*))
  flops]
@

<<C99 emit-op operations>>=
[(int-and) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a & ~a;" (car out*) (car in*) (cadr in*))
  flops]
@

<<C99 emit-op operations>>=
[(int-or) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a | ~a;" (car out*) (car in*) (cadr in*))
  flops]
@

<<C99 emit-op operations>>=
[(int-xor) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a ^ ~a;" (car out*) (car in*) (cadr in*))
  flops]
@

<<C99 emit-op operations>>=
[(int-not) (check-put* out* 1) (check-put* in* 1)
  (do-emit l "~a = ! ~a;" (car out*) (car in*))
  flops]
@

Next are double operations
<<C99 emit-op operations>>=
[(double-neg) (check-put* out* 1) (check-put* in* 1)
  (do-emit l "~a = - ~a;" (car out*) (car in*))
  (+ flops 1)]
@

<<C99 emit-op operations>>=
[(double-add) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a + ~a;" (car out*) (car in*) (cadr in*))
  (+ flops 1)]
@

<<C99 emit-op operations>>=
[(double-sub) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a - ~a;" (car out*) (car in*) (cadr in*))
  (+ flops 1)]
@

<<C99 emit-op operations>>=
[(double-div) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a / ~a;" (car out*) (car in*) (cadr in*))
  (+ flops 1)] ; This is optimistic, of course.
@

<<C99 emit-op operations>>=
[(double-mul) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a * ~a;" (car out*) (car in*) (cadr in*))
  (+ flops 1)]
@

<<C99 emit-op operations>>=
[(double-madd) (check-put* out* 1) (check-put* in* 3)
  (do-emit l "~a = ~a * ~a + ~a;" (car out*) (car in*) (cadr in*) (caddr in*))
  (+ flops 2)]
@

Finally, complex operations. We count the minimal number of floating point
operations needed, but some compilers are not very good with $i$.
<<C99 emit-op operations>>=
[(complex-neg) (check-put* out* 1) (check-put* in* 1)
  (do-emit l "~a = - ~a;" (car out*) (car in*))
  (+ flops 2)]
@

<<C99 emit-op operations>>=
[(complex-add) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a + ~a;" (car out*) (car in*) (cadr in*))
  (+ flops 2)]
@

<<C99 emit-op operations>>=
[(complex-sub) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a - ~a;" (car out*) (car in*) (cadr in*))
  (+ flops 2)]
@

<<C99 emit-op operations>>=
[(complex-mul) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a * ~a;" (car out*) (car in*) (cadr in*))
  (+ flops 6)]
@

<<C99 emit-op operations>>=
[(complex-madd) (check-put* out* 1) (check-put* in* 3)
  (do-emit l "~a = ~a * ~a + ~a;" (car out*) (car in*) (cadr in*) (caddr in*))
  (+ flops 8)]
@

<<C99 emit-op operations>>=
[(complex-cmul) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = conj(~a) * ~a;" (car out*) (car in*) (cadr in*))
  (+ flops 6)]
@

<<C99 emit-op operations>>=
[(complex-cmadd) (check-put* out* 1) (check-put* in* 3)
  (do-emit l "~a = conj(~a) * ~a + ~a;"
           (car out*) (car in*) (cadr in*) (caddr in*))
  (+ flops 8)]
@

<<C99 emit-op operations>>=
[(complex-add-i) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a + I * ~a;" (car out*) (car in*) (cadr in*))
  (+ flops 2)]
@

<<C99 emit-op operations>>=
[(complex-sub-i) (check-put* out* 1) (check-put* in* 2)
  (do-emit l "~a = ~a - I * ~a;" (car out*) (car in*) (cadr in*))
  (+ flops 2)]
@

Finally,
<<File [[backends.ss]]>>=
(define (machine-c99-32 env)
  <<C99 back-end types>>
  (let* ([env (machine-*-32 env c99-op* c99-load*)]
         [env (ce-bind env 'back-end c99-back-end)]
	 [env (ce-bind env 'be-emit c99-emit)])
    env))
  
@

<<C99 back-end types>>=
(define c99-op* '(
  (complex-add               complex-double)
  (complex-add-i             complex-double)
  (complex-cmadd             complex-double)
  (complex-cmul              complex-double)
  (complex-madd              complex-double)
  (complex-move              complex-double)
  (complex-mul               complex-double)
  (complex-neg               complex-double)
  (complex-sub               complex-double)
  (complex-sub-i             complex-double)
  (double-add                double)
  (double-div                double)
  (double-madd               double)
  (double-move               double)
  (double-mul                double)
  (double-neg                double)
  (double-sub                double)
  (int-add                   int)
  (int-and                   int)
  (int-div                   int)
  (int-mod                   int)
  (int-move                  int)
  (int-mul                   int)
  (int-or                    int)
  (int-sub                   int)
  (int-xor                   int)
  (pointer-add               pointer)
  (pointer-move              pointer)
))
@

<<C99 back-end types>>=
(define c99-load* '(
   (int               int)
   (pointer           pointer)
   (float             double)
   (double            double)
   (complex-float     complex-double)
   (complex-double    complex-double)))
@

\section{BG/L}
The machine settings for BG/L:
<<Folding environment routines>>=
(define (ce-bgl env)
  (let* ([env (ce-add-type env 'int            "int"              4  4)]
         [env (ce-add-type env 'pointer        "void *"           4  4)]
         [env (ce-add-type env 'float          "float"            4  4)]
         [env (ce-add-type env 'double         "double"           8  8)]
         [env (ce-add-type env 'vector-float   "vector float"     8  8)]
         [env (ce-add-type env 'vector-double  "vector double"   16 16)]
         [env (ce-add-type env 'complex-float  "float _Complex"   8  8)]
         [env (ce-add-type env 'complex-double "double _Complex" 16 16)]
         [env (ce-add-const env '*colors*            3)]
         [env (ce-add-const env '*DIM*               4)]
         [env (ce-add-const env '*fermion-dim*       4)]
         [env (ce-add-const env '*half-fermion-dim*  2)])
    env))
@

\section{MACROS}
Useful macros for R5RS with [[syntax-case]]. First, progress reporting:
<<File [[common.ss]]>>=
(define *verbose?* #f)
(define (progress-report fmt . args)
  (if *verbose?*
      (begin (printf "  ")
             (apply printf format args)
             (printf "...~%")
             (flush-output-port (current-output-port)))))
@
Also, my favorite debugging procedure
<<File [[common.ss]]>>=
(define (dbg . msg)
   (display "D:")
   (for-each (lambda (x) (display " ") (write x)) msg)
   (newline)
   #f)
@
Next, assertions.
<<File [[common.ss]]>>=
(define-syntax assert
  (lambda (x)
    (syntax-case x ()
      [(_ test fmt arg ...)
       (syntax (if (not test) (error 'assert (string-append "FAILED: " fmt)
                                     arg ...)))])))
@
For [[define-variant]] we need to be able to inject new names into the current
lexical environment. The code below does the Right Thing.
<<File [[common.ss]]>>=
(define-syntax define-variant
  (lambda (x)
    <<Define [[mk-name]]>>
    (syntax-case x ()
      [(_ name (field ...))
       (with-syntax (
          <<Injected names for [[define-syntax]]>>
         )
         (with-syntax
           ([(index ...) (let f ([i 1])
                            (if (= i (syntax-object->datum (syntax count))) '()
                                (cons i (f (+ 1 i)))))])
           (syntax
             (begin
               <<[[variant]] definitions>>
             ))))])))
@

<<Define [[mk-name]]>>=
(define (mk-name template-id . args)
  (datum->syntax-object template-id
    (string->symbol (apply string-append
                           (map (lambda (x)
                                  (if (string? x) x
                                      (symbol->string (syntax-object->datum x))))
                                args)))))
@
Now define the names used by [[variant]]:
<<Injected names for [[define-syntax]]>>=
[constructor (mk-name (syntax name) 'make- (syntax name))]
[predicate (mk-name (syntax name) (syntax name) '?)]
[(reader ...) (map (lambda (field)
                     (mk-name (syntax name) (syntax name) "->" field))
                   (syntax (field ...)))]
[count (length (syntax (name field ...)))]
@

Finally, we can expand a new [[variant]] into corresponding defintions:
<<[[variant]] definitions>>=
(define constructor (lambda (field ...) (vector 'name field ...)))
(define predicate (lambda (object)
                    (and (vector? object)
                         (= (vector-length object) count)
                         (eq? (vector-ref object 0) 'name))))
(define reader (lambda (object) (vector-ref object index))) ...
@

Here is a generic variant discriminator:
<<File [[common.ss]]>>=
(define variant-type (lambda (variant) (vector-ref variant 0)))
@

These variants are very useful with the [[variant-case]]:
<<File [[common.ss]]>>=
(define-syntax variant-case
  (lambda (x)
    <<Define [[mk-name]]>>
    (syntax-case x (else)
      [(_ exp clause ...) (not (identifier? (syntax exp)))
          (syntax (let ([var exp]) (_ var clause ...)))]
      [(_ var) (syntax (error 'variant-case "no clause matches ~a" var))]
      [(_ var (else exp exp1 ...)) (syntax (begin exp exp1 ...))]
      [(_ var (name [(fname field) ...] exp1 exp2 ...) clause ...)
       (with-syntax
         ([predicate (mk-name (syntax name) (syntax name) '?)]
          [(reader ...) (map (lambda (fld)
                               (mk-name (syntax name) (syntax name) "->" fld))
                             (syntax (field ...)))])
         (syntax (if (predicate var)
                     (let ([fname (reader var)] ...) exp1 exp2 ...)
                     (_ var clause ...))))]
      [(_ var (name (field ...) exp1 exp2 ...) clause ...)
       (syntax (_ var (name ([field field] ...) exp1 exp2 ...) clause ...))])))
@

Finally, [[let-values*]]:
<<File [[common.ss]]>>=
(define-syntax let-values*
  (lambda (x)
    (syntax-case x ()
      [(_ () e ...) (syntax (let () e ...))]
      [(_ ([(n ...) i ...]) e ...) (syntax (call-with-values
                                             (lambda () (let () i ...))
                                             (lambda (n ...) (let () e ...))))]
      [(_ ([n i ...]) e ...) (syntax (let ([n (let () i ...)]) (let () e ...)))]
      [(_ (b0 b1 ...) e ...) (syntax (_ (b0) (_ (b1 ...) e ...)))])))
@

\section{CODE CHUNKS}
\nowebchunks

\end{document}
